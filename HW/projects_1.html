<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Projects 1 – Stat 24320</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="project_styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#instructions" id="toc-instructions" class="nav-link active" data-scroll-target="#instructions"><em>Instructions</em></a></li>
  <li><a href="#chapter-1-projects" id="toc-chapter-1-projects" class="nav-link" data-scroll-target="#chapter-1-projects"><em>Chapter 1 projects</em></a>
  <ul class="collapse">
  <li><a href="#gas-in-a-tube" id="toc-gas-in-a-tube" class="nav-link" data-scroll-target="#gas-in-a-tube"><em>Gas in a Tube</em></a></li>
  </ul></li>
  <li><a href="#chapter-2-projects" id="toc-chapter-2-projects" class="nav-link" data-scroll-target="#chapter-2-projects"><em>Chapter 2 Projects</em></a>
  <ul class="collapse">
  <li><a href="#lu-factorization" id="toc-lu-factorization" class="nav-link" data-scroll-target="#lu-factorization"><em>LU Factorization</em></a></li>
  <li><a href="#markov-chains" id="toc-markov-chains" class="nav-link" data-scroll-target="#markov-chains"><em>Markov Chains</em></a></li>
  <li><a href="#sports-ranking" id="toc-sports-ranking" class="nav-link" data-scroll-target="#sports-ranking"><em>Sports Ranking</em></a></li>
  <li><a href="#isorank" id="toc-isorank" class="nav-link" data-scroll-target="#isorank"><em>IsoRank</em></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projects 1</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<script id="quarto-computed-dates" type="application/json">
{"publish-solutions-on-computed": "2026-02-04", "due-date-computed": "2026-01-30"}
</script>
<h1 id="instructions"><em>Instructions</em></h1>
<ol type="1">
<li>Pick three projects from the list below.</li>
<li>Please format each project as a Jupyter notebook or a Quarto document (or some similar format which allows me to see/run code.)</li>
<li>You are welcome to work with a partner on some or all of the projects, but please make sure you are each contributing to each part of the project – don’t just divide up the work.
<ol type="1">
<li>If you work with a partner, you may choose to submit one report for both of you, or you may submit separate reports. Either way, please make sure to indicate who your partner was. (Please indicate very clearly what you are doing – which reports if any are joint, and with whom, etc, so I don’t get confused!)</li>
</ol></li>
<li>This is the first time I’m assigning something like this, so please feel to reach out with questions or suggestions for improvement.</li>
<li>Projects will be due on Friday night, 11:59pm.</li>
</ol>
<h1 id="chapter-1-projects"><em>Chapter 1 projects</em></h1>
<h2 id="gas-in-a-tube" class="anchored"><em>Gas in a Tube</em></h2>
<p>(Shores 62)</p>
<p>Problem Description: You are given a long tube of still dry air in which there are 7 sampling/insertion points equally spaced <span class="math inline">\(1 / 6\)</span> meters apart from each other. The position of each point is measured by setting the leftmost point at 0.0 meters and rightmost at 1.0 meters. Initially, a small amount of a certain gas is inserted in the central insertion point. Subsequently, measurements of the concentration of the gas at each sampling/insertion point are taken at later times in seconds. The results of these measurements, which you may assume are accurate to about 2-3 digits, are specified in Table 1.1. Based on this information, your task is to determine the best estimate you can find for the true value of the diffusion coefficient <span class="math inline">\(D\)</span> of this gas in a motionless air medium. Use this estimate and a marching method to calculate values of the material density function on the interval <span class="math inline">\([0,1]\)</span> at times <span class="math inline">\(t=210\)</span> and <span class="math inline">\(t=300\)</span> and at the given spatial nodes.</p>
<table class="caption-top table">
<caption>Concentration data measurements of a gaseous material.</caption>
<colgroup>
<col style="width: 28%">
<col style="width: 7%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>Sec <span class="math inline">\(\backslash\)</span> Meter</th>
<th>0</th>
<th><span class="math inline">\(1 / 6\)</span></th>
<th><span class="math inline">\(1 / 3\)</span></th>
<th><span class="math inline">\(1 / 2\)</span></th>
<th><span class="math inline">\(2 / 3\)</span></th>
<th><span class="math inline">\(5 / 6\)</span></th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(t=240\)</span></td>
<td>0.0</td>
<td>0.032</td>
<td>1.23</td>
<td>3.69</td>
<td>1.23</td>
<td>0.032</td>
<td>0.0</td>
</tr>
<tr class="even">
<td><span class="math inline">\(t=270\)</span></td>
<td>0.0</td>
<td>0.051</td>
<td>1.21</td>
<td>3.48</td>
<td>1.21</td>
<td>0.051</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<p>Procedure: You should use equation (1.10) or some variant to move backward and forward in time. These will result in linear systems, which ALAMA calculator or another technology tool can solve. One way to proceed is simply to use trial and error until you think you’ve hit on a reasonable value of <span class="math inline">\(D\)</span>, that is, the one that gives the best approximation to <span class="math inline">\(t=240\)</span> from the <span class="math inline">\(t=270\)</span> values. Do not expect perfect matches - the data is relatively sparse. Then march backwards in time once more to get the initial values at <span class="math inline">\(t=0\)</span>. Finally, march forward in time to compute and plot the resulting approximate density function.</p>
<p>Output: Discus your results and provide a graph of profiles of the material density function at times in the data table along with your computed profiles.</p>
<p>Comments: This project introduces you to a very interesting area of mathematics called “inverse theory.” The idea is, rather than proceeding from problem (the governing equations for concentration values) to solution (concentration profiles), you are given the “solution,” namely the measured solution values at various points, and are to determine from this information the “problem,” i.e., the diffusion coefficient needed to define the governing equations.</p>
<h1 id="chapter-2-projects"><em>Chapter 2 Projects</em></h1>
<h2 id="lu-factorization" class="anchored"><em>LU Factorization</em></h2>
<p><em>We didn’t yet get to the discussion of this in class. If you’re interested in doing this project, you can look at the second part of the Chapter 2 Lecture 4 slides.</em></p>
<p>(Shores p.&nbsp;177) Write a program module that implements Theorem 2.14 using partial pivoting and implicit row exchanges. This means that space is allocated for the <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A=[a[i, j]]\)</span> and an array of row indices, say indx <span class="math inline">\([i]\)</span>. Initially, indx should consist of the integers <span class="math inline">\(1,2, \ldots, n\)</span>. Whenever two rows need to be exchanged, say the first and third, then the indices indx[1] and indx[3] are exchanged. References to array elements throughout the Gaussian elimination process should be indirect: Refer to the <span class="math inline">\((1,4)\)</span> th entry of <span class="math inline">\(A\)</span> as the element <span class="math inline">\(a[\operatorname{indx}[1], 4]\)</span>. This method of reference has the same effect as physically exchanging rows, but without the work. It also has the appealing feature that we can design the algorithm as though no row exchanges have taken place provided we replace the direct reference <span class="math inline">\(a[i, j]\)</span> by the indirect reference <span class="math inline">\(a[\operatorname{indx}[i], j]\)</span>. The module should return the lower/upper matrix in the format of Example 2.70 as well as the permuted array indx <span class="math inline">\([i]\)</span>. Effectively, this index array tells the user what the permutation matrix <span class="math inline">\(P\)</span> is.</p>
<p>Use this module to implement an LU system solver module that uses the <span class="math inline">\(\mathrm{LU}\)</span> factorization to solve a general linear system. Also write a module that finds the inverse of an <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span> by first using the LU factorization module, then making repeated use of the LU system solver to solve <span class="math inline">\(A \mathbf{x}^{(i)}=\mathbf{e}_{i}\)</span>, where <span class="math inline">\(\mathbf{e}_{i}\)</span> is the <span class="math inline">\(i\)</span> th column of the identity. Then we will have</p>
<p><span class="math display">\[
A^{-1}=\left[\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \ldots, \mathbf{x}^{(n)}\right]
\]</span></p>
<p>Be sure to document and test your code and report on the results.</p>
<h2 id="markov-chains" class="anchored"><em>Markov Chains</em></h2>
<p>(Shores p.&nbsp;177)</p>
<p>Refer to Example 2.19 and Section 2.3 for background. Three automobile insurance firms compete for a fixed market of customers. Annual premiums are sold to these customers. Label the companies A, B, and C. You work for Company A, and your team of market analysts has done a survey that draws the following conclusions: In each of the past three years, the number of A customers switching to B is <span class="math inline">\(20 \%\)</span>, and to <span class="math inline">\(\mathrm{C}\)</span> is <span class="math inline">\(30 \%\)</span>. The number of <span class="math inline">\(\mathrm{B}\)</span> customers switching to <span class="math inline">\(\mathrm{A}\)</span> is <span class="math inline">\(20 \%\)</span>, and to <span class="math inline">\(\mathrm{C}\)</span> is <span class="math inline">\(20 \%\)</span>. The number of <span class="math inline">\(\mathrm{C}\)</span> customers switching to <span class="math inline">\(\mathrm{A}\)</span> is <span class="math inline">\(30 \%\)</span>, and to <span class="math inline">\(\mathrm{B}\)</span> is <span class="math inline">\(10 \%\)</span>. Those who do not switch continue to use their current company’s insurance for the next year. Model this market as a Markov chain. Display the transition matrix for the model. Illustrate the workings of the model by showing what it would predict as the market shares three years from now if currently <span class="math inline">\(\mathrm{A}, \mathrm{B}\)</span>, and <span class="math inline">\(\mathrm{C}\)</span> owned equal shares of the market.</p>
<p>The next part of your problem is as follows: Your team has tested two advertising campaigns in some smaller test markets and are confident that the first campaign will convince <span class="math inline">\(20 \%\)</span> of the B customers who would otherwise stay with B in a given year to switch to A. The second advertising campaign would convince <span class="math inline">\(20 \%\)</span> of the <span class="math inline">\(\mathrm{C}\)</span> customers who would otherwise stay with C in a given year to switch to A. Both campaigns have about equal costs and would not change other customers’ habits. Make a recommendation, based on your experiments with various possible initial state vectors for the market. Will these campaigns actually improve your company’s market share? If so, which one do you recommend? Write up your recommendation in the form of a report, with supporting evidence. It’s a good idea to hedge on your bets a little by pointing out limitations to your model and claims, so devote a few sentences to those points.</p>
<p>It would be a plus to carry the analysis further (your manager might appreciate that). For instance, you could turn the additional market share from, say B customers, into a variable and plot the long-term gain for your company against this variable. A manager could use this data to decide whether it was worthwhile to attempt gaining more customers from B.</p>
<h2 id="sports-ranking" class="anchored"><em>Sports Ranking</em></h2>
<p>(Shores p.&nbsp;180)</p>
<p>Refer to Example 2.24 and Section 2.3 for background. As a sports analyst you are given the following data about a league of seven teams numbered 1-7, where the pair <span class="math inline">\((j, k)\)</span> represents a game in which team <span class="math inline">\(j\)</span> defeated team <span class="math inline">\(k\)</span> :</p>
<p><span class="math display">\[
\begin{aligned}
E= &amp; \{(1,2),(7,3),(2,4),(4,5),(3,2),(5,1),(6,1),(3,1),(7,2),(2,6), \\
&amp; (3,4),(7,4),(5,7),(6,4),(3,5),(5,6),(7,1),(5,2),(7,6),(1,4),(6,3)\}
\end{aligned}
\]</span></p>
<p>Based on these data you are to rank the teams. To this end, begin with the simplest method, ranking by win/loss record. Next, treat the data as defining a digraph. Begin this analysis by constructing the adjacency matrix of this digraph and drawing a picture of the digraph either by hand or using some software. Then rank the teams by using the following methods: First use the method of Example 2.26 to find a power ranking of each team. Then use the reverse PageRank idea of Example 2.47 to rank the the teams.</p>
<p>Next, suppose you are given additional information, namely, the game margins (winning score minus losing score) for each game. Following is a list of these margins matching the order of matches in the definition of <span class="math inline">\(E\)</span> :</p>
<p><span class="math display">\[
M=\{4,8,7,3,7,7,23,15,6,18,13,14,7,13,7,18,45,10,19,14,13\}
\]</span></p>
<p>In order to utilize these data examine your picture of the digraph and label each edge with the margin that matches it in <span class="math inline">\(M\)</span>. You are now dealing with a weighted graph and one can construct a different sort of “adjacency matrix” by entering this margin in the <span class="math inline">\((i, j)\)</span> th entry according as team <span class="math inline">\(i\)</span> defeated team <span class="math inline">\(j\)</span> by that margin. Use this approach to calculate “power ranking”.</p>
<h2 id="isorank" class="anchored"><em>IsoRank</em></h2>
<p>Read the discussion of <em>IsoRank</em> on pages 172-176.</p>
<p>The notion of embedding one graph into another is a useful idea for some scientific studies. In this report you will test the basic idea of network embedding by using the variant IsoRank of the PageRank technique on three relatively simple examples. This project requires a technology tool for these calculations and the resulting output should be interpreted as in the discussion of the IsoRank technique following Example 2.73 of Section 2.8.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://cdn.mathpix.com/cropped/2024_02_16_adbe27593182d62240abg-191.jpg?height=298&amp;width=582&amp;top_left_y=468&amp;top_left_x=468" class="img-fluid figure-img"></p>
<figcaption>Figure 2.13</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://cdn.mathpix.com/cropped/2024_02_16_adbe27593182d62240abg-191.jpg?height=242&amp;width=914&amp;top_left_y=875&amp;top_left_x=300" class="img-fluid figure-img"></p>
<figcaption>Figure 2.14</figcaption>
</figure>
</div>
<p>By an isomorphism of graphs we mean a one-to-one edge preserving map of vertices from one graph onto another. One can think of an isomorphism as simply a relabeling of the vertices of a graph. The first test is to provide an example of how well IsoRank can recognize isomorphisms. Consider the graph of Figure 2.13. Let <span class="math inline">\(G_{1}\)</span> be the graph with vertices <span class="math inline">\(1,2,3,4,5\)</span> in that order and <span class="math inline">\(G_{2}\)</span> the same graph with vertices <span class="math inline">\(A, B, C, D, E\)</span> in that order. Apply IsoRank to these two graphs and discuss the validity of your results.</p>
<p>The next embedding test is to remove the edge connecting vertices <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> in Figure 2.12 and use IsoRank with teleportation vector <span class="math inline">\(\mathbf{v}=\mathbf{e} / 15\)</span> and teleportation parameter <span class="math inline">\(\alpha=0.85\)</span> to find the best matchings of the graph <span class="math inline">\(G_{1}\)</span> with the resulting graph <span class="math inline">\(G_{2}\)</span>. List all possible mappings that are calculated.</p>
<p>The last embedding test is to use IsoRank with teleportation vector <span class="math inline">\(\mathbf{v}=\)</span> <span class="math inline">\(\mathrm{e} / 15\)</span> and teleportation parameter <span class="math inline">\(\alpha=0.85\)</span>, along with correction vector <span class="math inline">\(\mathbf{u}=\mathbf{e} / 5\)</span> for <span class="math inline">\(G_{2}\)</span>, to find the best matchings of the digraph <span class="math inline">\(G_{1}\)</span> with the digraph <span class="math inline">\(G_{2}\)</span> in Figure 2.14. List all possible mappings and discuss your calculations.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>