<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Projects 3 – Stat 24320</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#revisiting-a-previous-project" id="toc-revisiting-a-previous-project" class="nav-link active" data-scroll-target="#revisiting-a-previous-project"><span class="header-section-number">1</span> <em>Revisiting a previous project</em></a></li>
  <li><a href="#quadratic-forms" id="toc-quadratic-forms" class="nav-link" data-scroll-target="#quadratic-forms"><span class="header-section-number">2</span> <em>Quadratic Forms</em></a></li>
  <li><a href="#management-of-sheep-populations" id="toc-management-of-sheep-populations" class="nav-link" data-scroll-target="#management-of-sheep-populations"><span class="header-section-number">3</span> <em>Management of Sheep Populations</em></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projects 3</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<script id="quarto-computed-dates" type="application/json">
{"due-date-computed": "2026-03-13", "publish-solutions-on-computed": "2026-03-18"}
</script>
<p><strong>Instructions:</strong></p>
<p>Choose <strong>two</strong> of the following projects to complete.</p>
<p>Please submit a zip file containing your code (in .ipynb or .qmd format), any data files you load in, and if possible a pdf of your notebook. (A link to a GitHub repository or Google CoLab notebook would also work, so long as they are publically accessible.)</p>
<section id="revisiting-a-previous-project" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> <em>Revisiting a previous project</em></h1>
<p>Revisit one of the previous projects using new concepts which we have learned since you first did the project. (The “Image Compression” project on page 389 of your textbook would be one example of this, but you may take this in any direction you like.)</p>
</section>
<section id="quadratic-forms" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> <em>Quadratic Forms</em></h1>
<p>In order to classify quadratic equations in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> one goes through roughly three steps. First, perform a rotation transformation of coordinates to get rid of mixed terms such as <span class="math inline">\(2 x y\)</span> in the quadratic equation <span class="math inline">\(x^{2}+2 x y-y^{2}+x-3 y=4\)</span>. Second, do a translation of coordinates to put the equation in a “standard form.” Third, identify the curve by your knowledge of the shape of a curve in that standard form. Standard forms are equations like <span class="math inline">\(x^{2} / 4+y^{2} / 2=1\)</span>, an ellipse with its axes along the <span class="math inline">\(x\)</span> - and <span class="math inline">\(y\)</span>-axes. It is the second-degree terms <span class="math inline">\(\left(x^{2}, 2 x y\right.\)</span>, and <span class="math inline">\(\left.y^{2}\right)\)</span> alone that determine the nature of a quadratic.</p>
<p>Now you’re ready for the rest of the story. Just as with curves in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, the basic shape of the surface of a quadric equation in <span class="math inline">\(x, y\)</span>, and <span class="math inline">\(z\)</span> is determined by the second-degree terms. So we will focus on an example with no first-degree terms, namely,</p>
<p><span class="math display">\[
Q(x, y, z)=2 x^{2}+4 y^{2}+6 z^{2}-4 x y-2 x z+2 y z=1 .
\]</span></p>
<p>The problem is this: find a change of coordinates that will make it clear what standard forms is represented by this surface – is it a sphere, a spheroid, or a tri-axial ellipsoid?</p>
<p>First you must express the so-called quadratic form <span class="math inline">\(Q(x, y, z)\)</span> in matrix form as <span class="math inline">\(Q(x, y, z)=\)</span> <span class="math inline">\([x, y, z] A[x, y, z]^{T}\)</span>.</p>
<p>Next, replace <span class="math inline">\(A\)</span> by the equivalent matrix <span class="math inline">\(\left(A+A^{T}\right) / 2\)</span>. (Check that if <span class="math inline">\(A\)</span> specifies the quadratic form <span class="math inline">\(Q\)</span>, then so will <span class="math inline">\(A^\prime = \left(A+A^{T}\right) / 2\)</span>.)</p>
<p>Next, diagonalize your symmetric matrix. You can use the command <code>diagonalize</code> in <code>sympy</code> to do this, but check that the results are what you’d expect given the eigenvalues and eigenvectors of your symmetric matrix. The result is a diagonal matrix <span class="math inline">\(D\)</span> and an orthogonal matrix <span class="math inline">\(P\)</span> such that <span class="math inline">\(P^{T} A^\prime P=D\)</span>.</p>
<p>Next, make the linear change of variables <span class="math inline">\([x, y, z]^{T}=P\left[x^{\prime}, y^{\prime}, z^{\prime}\right]^{T}\)</span> and deduce that <span class="math inline">\(Q(x, y, z)=\)</span> <span class="math inline">\(\left[x^{\prime}, y^{\prime}, z^{\prime}\right] P^{T} A^\prime P\left[x^{\prime}, y^{\prime}, z^{\prime}\right]^{T}\)</span>. If <span class="math inline">\(P^{T} A^\prime P\)</span> is diagonal, we end up with squares of <span class="math inline">\(x^{\prime}, y^{\prime}\)</span> and <span class="math inline">\(z^{\prime}\)</span>, and no mixed terms.</p>
<p>From this data alone you should be able to classify the surface represented by the above equation.</p>
<p>Confirm your results by plotting the surface in the new coordinates.</p>
<p>An outstanding reference on this topic and many others relating to matrix analysis is the recently republished textbook [3] by Richard Bellman, widely considered to be a classic in the field.</p>
<p>(Hint: when I did this problem, I encountered very small imagainary part at certain points. I used the <code>sp.nsimplify(sp.N(f),rational=True)</code> function to get rid of these.)</p>
</section>
<section id="management-of-sheep-populations" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> <em>Management of Sheep Populations</em></h1>
<p>Description of the problem: You are working for the New Zealand Department of Agriculture on a project for sheep farmers. The species of sheep that these shepherds raise have a life span of 12 years. Of course, some live longer, but they are sufficiently few in number and their reproductive rate is so low that they may be ignored in your population study. Accordingly, you divide sheep into 12 age classes, namely those in the first year of life, etc. An extensive survey of the demographics of this species of sheep results in the following approximations for the demographic parameters <span class="math inline">\(f_{i}\)</span> and <span class="math inline">\(s_{i}\)</span>, where <span class="math inline">\(f_{i}\)</span> is the percapita reproductive rate for sheep in the <span class="math inline">\(i\)</span> th age class and <span class="math inline">\(s_{i}\)</span> is the survival rate for sheep in that age class, i.e., the fraction of sheep in that age class that survive to the <span class="math inline">\((i+1)\)</span> th class. (As a matter of fact, this table is related to real data. The interested reader might consult the article [7] in the bibliography.)</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(i\)</span></th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">12</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(f_{i}\)</span></td>
<td style="text-align: center;">.000</td>
<td style="text-align: center;">.023</td>
<td style="text-align: center;">.145</td>
<td style="text-align: center;">.236</td>
<td style="text-align: center;">.242</td>
<td style="text-align: center;">.273</td>
<td style="text-align: center;">.271</td>
<td style="text-align: center;">.251</td>
<td style="text-align: center;">.234</td>
<td style="text-align: center;">.229</td>
<td style="text-align: center;">.216</td>
<td style="text-align: center;">.210</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(s_{i}\)</span></td>
<td style="text-align: center;">.845</td>
<td style="text-align: center;">.975</td>
<td style="text-align: center;">.965</td>
<td style="text-align: center;">.950</td>
<td style="text-align: center;">.926</td>
<td style="text-align: center;">.895</td>
<td style="text-align: center;">.850</td>
<td style="text-align: center;">.786</td>
<td style="text-align: center;">.691</td>
<td style="text-align: center;">.561</td>
<td style="text-align: center;">.370</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>The problem is as follows: in order to maintain a constant population of sheep, shepherds will harvest a certain number of sheep each year. Harvesting need not mean slaughter; it simply means removing sheep from the population (e.g., selling animals to other shepherds). Denote the fraction of sheep that are removed from the <span class="math inline">\(i\)</span> th age group at the end of each growth period (a year in our case) by <span class="math inline">\(h_{i}\)</span>. If these numbers are constant from year to year, they constitute a harvesting policy. If, moreover, the yield of each harvest, i.e., total number of animals harvested each year, is a constant and the age distribution of the remaining populace is essentially constant after each harvest, then the harvesting policy is called sustainable. If all the <span class="math inline">\(h_{i}\)</span> ’s are the same, say <span class="math inline">\(h\)</span>, then the harvesting policy is called uniform. Uniform policies are simple to implement: One selects the sheep to be harvested at random.</p>
<p>Your problem: Find a uniform sustainable harvesting policy to recommend to shepherds, and find the resulting distribution of sheep that they can expect with this policy. Shepherds who raise sheep for sale to markets are also interested in a sustainable policy that gives a maximum yield. If you can find such a policy that has a larger annual yield than the uniform policy, then recommend it. On the other hand, shepherds who raise sheep for their wool may prefer to minimize the annual yield. If you can find a sustainable policy whose yield is smaller than that of the uniform policy, make a recommendation accordingly. In each case find the expected distribution of your harvesting policies. Do you think that there might be other economic factors that should be taken into account in this model? Organize your results for a report to be read by your supervisor and an informed public.</p>
<p>Procedure: Express this problem as a discrete linear dynamical system <span class="math inline">\(\mathbf{x}^{(k+1)}=L \mathbf{x}^{(k)}\)</span>, where <span class="math inline">\(L\)</span> is a so-called Leslie matrix of the form</p>
<p><span class="math display">\[
L=\left[\begin{array}{cccccc}
f_{1} &amp; f_{2} &amp; f_{3} &amp; \cdots &amp; f_{n-1} &amp; f_{n} \\
s_{1} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; s_{2} &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; s_{n-1} &amp; 0
\end{array}\right]
\]</span></p>
<p>It is understood that <span class="math inline">\(0&lt;s_{i} \leq 1,0 \leq f_{i}\)</span>, and at least one <span class="math inline">\(f_{i}\)</span> is nonzero.</p>
<p>In regard to harvesting, let <span class="math inline">\(H\)</span> be a diagonal matrix with the harvest fractions <span class="math inline">\(h_{i}\)</span> down the diagonal. (Here <span class="math inline">\(0 \leq h_{i} \leq 1\)</span>.) Then the population that results from this harvesting at the end of each period is given by <span class="math inline">\(\mathbf{x}^{k+1}=L \mathbf{x}^{k}-H L \mathbf{x}^{k}=(I-H) L \mathbf{x}^{k}\)</span>. There are other theoretical tools, but all you need to do is to find a matrix <span class="math inline">\(H\)</span> such that 1 is the dominant eigenvalue of <span class="math inline">\((I-H) L\)</span>. You can do this by trial and error, a method that is applicable to any harvesting policy, uniform or not. However, in the case of uniform policies it’s simpler to note that <span class="math inline">\((I-H) L=(1-h) L\)</span>, where <span class="math inline">\(h\)</span> is the diagonal entry of <span class="math inline">\(H\)</span>. Find an eigenvector corresponding to this eigenvalue and scale this vector by dividing it by the sum of its components to obtains a probability distribution vector that could be used for any population.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>