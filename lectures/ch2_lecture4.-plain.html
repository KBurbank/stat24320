<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Stat 24320 - Ch2 Lecture 4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ch2_lecture4.html"><i class="bi bi-file-slides"></i>RevealJS</a></li><li><a href="ch2_lecture4.out.ipynb" download="ch2_lecture4.out.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Ch2 Lecture 4</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!--
### LU Factorization

Here is a problem: Suppose we want to solve a nonsingular linear system $A x=b$ repeatedly, with different choices of $b$. A perfect example of this kind of situation is the heat flow problem Example 1.3, where the right-hand side is determined by the heat source term $f(x)$. Suppose that we need to experiment with different source terms. What happens if we use Gaussian or Gauss-Jordan elimination? Each time we carry out a complete calculation on the augmented matrix $\widetilde{A}=[A \mid b]$ we have to resolve the whole system. Yet, the main part of our work is the same: putting the part of $\widetilde{A}$ corresponding to the coefficient matrix $A$ into reduced row echelon form. Changing the right-hand side has no effect on this work. What we want here is a way to somehow record our work on $A$, so that solving a new system involves very little additional work. This is exactly what the LU factorization is all about.

#### Definition 2.24.
 LU Factorization Let $A$ be an $n \times n$ matrix. An LU factorization of $A$ is a pair of $n \times n$ matrices $L, U$ such that

(1) $L$ is lower triangular.

(2) $U$ is upper triangular.

(3) $A=L U$.

Even if we could find such beasts, what is so wonderful about them? The answer is that triangular systems $A \mathbf{x}=\mathbf{b}$ are easy to solve. For example, if $A$ is upper triangular, we learned that the smart thing to do was to use the last equation to solve for the last variable, then the next-to-last equation for the next-to-last variable, etc. This is the secret of Gaussian elimination! But lower triangular systems are just as simple: Use the first equation to solve for the first variable, the second equation for the second variable, and so forth. Now suppose we want to solve $A \mathbf{x}=\mathbf{b}$ and we know that $A=L U$. The original system becomes $L U \mathbf{x}=\mathbf{b}$. Introduce an intermediate variable $\mathbf{y}=U \mathbf{x}$. Now perform these steps:

1. (Forward solve) Solve lower triangular system $L \mathbf{y}=\mathbf{b}$ for the variable $\mathbf{y}$.
2. (Back solve) Solve upper triangular system $U \mathbf{x}=\mathbf{y}$ for the variable $\mathbf{x}$.

This does it! Once we have the matrices $L, U$, we don't have to worry about right-hand sides, except for the small amount of work involved in solving two triangular systems. Notice that since $A$ is assumed nonsingular, we have that if $A=L U$, then $\operatorname{det} A=\operatorname{det} L \operatorname{det} U \neq 0$. Therefore, neither triangular matrix $L$ or $U$ can have zeros on its diagonal. Thus, the forward and back solve steps can always be carried out to give a unique solution.

Example 2.69. You are given that

$$
A=\left[\begin{array}{rrr}
2 & 1 & 0 \\
-2 & 0 & -1 \\
2 & 3 & -3
\end{array}\right]=\left[\begin{array}{rrr}
1 & 0 & 0 \\
-1 & 1 & 0 \\
1 & 2 & 1
\end{array}\right]\left[\begin{array}{rrr}
2 & 1 & 0 \\
0 & 1 & -1 \\
0 & 0 & -1
\end{array}\right] .
$$

Use this fact to solve $A x=b$ in the following cases:

(a) $\mathbf{b}=[1,0,1]^{T}$

(b) $\mathbf{b}=[-1,2,1]^{T}$

Solution. Set $\mathbf{x}=\left[x_{1}, x_{2}, x_{3}\right]^{T}$ and $\mathbf{y}=\left[y_{1}, y_{2}, y_{3}\right]^{T}$. For (a) forward solve

$$
\left[\begin{array}{rrr}
1 & 0 & 0 \\
-1 & 1 & 0 \\
1 & 2 & 1
\end{array}\right]\left[\begin{array}{l}
y_{1} \\
y_{2} \\
y_{3}
\end{array}\right]=\left[\begin{array}{l}
1 \\
0 \\
1
\end{array}\right]
$$

to get $y_{1}=1$, then $y_{2}=0+1 y_{1}=1$, then $y_{3}=1-1 y_{1}-2 y_{2}=-2$. Then back solve

$$
\left[\begin{array}{rrr}
2 & 1 & 0 \\
0 & 1 & -1 \\
0 & 0 & -1
\end{array}\right]\left[\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right]=\left[\begin{array}{r}
1 \\
1 \\
-2
\end{array}\right]
$$

to get $x_{3}=-2 /(-1)=2$, then $x_{2}=1+x_{3}=3$, then $x_{1}=\left(1-1 x_{2}\right) / 2=-1$.

For (b) forward solve

$$
\left[\begin{array}{rrr}
1 & 0 & 0 \\
-1 & 1 & 0 \\
1 & 2 & 1
\end{array}\right]\left[\begin{array}{l}
y_{1} \\
y_{2} \\
y_{3}
\end{array}\right]=\left[\begin{array}{r}
-1 \\
2 \\
1
\end{array}\right]
$$

to get $y_{1}=-1$, then $y_{2}=0+1 y_{1}=-1$, then $y_{3}=1-1 y_{1}-2 y_{2}=4$. Then back solve

$$
\left[\begin{array}{rrr}
2 & 1 & 0 \\
0 & 1 & -1 \\
0 & 0 & -1
\end{array}\right]\left[\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3}
\end{array}\right]=\left[\begin{array}{r}
-1 \\
-1 \\
4
\end{array}\right]
$$

to get $x_{3}=4 /(-1)=-4$, then $x_{2}=1+x_{3}=-3$, then $x_{1}=\left(1-1 x_{2}\right) / 2=2$.

Notice how simple the previous example was, if LU factorization is known. So how do we find such a factorization? In general, a nonsingular matrix may not have one. A good example is the matrix $\left[\begin{array}{ll}0 & 1 \\ 1 & 0\end{array}\right]$. However, if Gaussian elimination can be performed on the matrix $A$ without row exchanges, then such a factorization is really a by-product of Gaussian elimination. In this case let $\left[a_{i j}^{(k)}\right]$ be the matrix obtained from $A$ after using the $k$ th pivot to clear out entries below it (thus, $A=\left[a_{i j}^{(0)}\right]$ ). Remember that in Gaussian elimination we need only two types of elementary operations, namely row exchanges and adding a multiple of one row to another. Furthermore, the only elementary operations of the latter type that we use are of this form: $E_{i j}\left(-a_{i j}^{(k)} / a_{j j}^{(k)}\right)$, where $\left[a_{i j}^{(k)}\right]$ is the matrix obtained from $A$ from the various elementary operations up to this point.

Multipliers The numbers $m_{i j}=-a_{i j}^{(k)} / a_{j j}^{(k)}$, where $i>j$, are sometimes called multipliers. In the way of notation, let us call a triangular matrix a unit triangular matrix if its diagonal entries are all 1's.

Theorem 2.13. If Gaussian elimination is used without row exchanges on the nonsingular matrix $A$, resulting in the upper triangular matrix $U$, and if $L$ is the unit lower triangular matrix whose entries below the diagonal are the negatives of the multipliers $m_{i j}$, then $A=L U$.

Proof. The proof of this theorem amounts to noticing that the product of all the elementary operations that reduces $A$ to $U$ is a unit lower triangular matrix $\widetilde{L}$ with the multipliers $m_{i j}$ in the appropriate positions. Thus, $\widetilde{L} A=U$. To undo these operations, multiply by a matrix $L$ with the negatives of the multipliers in the appropriate positions. This results in

$$
L \widetilde{L} A=A=L U
$$

as desired.

The following example shows how one can write an efficient program to implement LU factorization. The idea is this: As we do Gaussian elimination, the $U$ part of the factorization gradually appears in the upper parts of the transformed matrices $A^{(k)}$. Below the diagonal we replace nonzero entries with zeros, column by column. Instead of wasting this space, use it to store the negative of the multipliers in place of the element it zeros out. Of course, this storage part of the matrix should not be changed by subsequent elementary row operations. When we are finished with elimination, the diagonal and upper part of the resulting matrix is just $U$, and the strictly lower triangular part on the unit lower triangular matrix $L$ is stored in the lower part of the matrix.

Example 2.70. Use the shorthand of the preceding discussion to compute an $\mathrm{LU}$ factorization for

$$
A=\left[\begin{array}{rrr}
2 & 1 & 0 \\
-2 & 0 & -1 \\
2 & 3 & -3
\end{array}\right]
$$

Solution. Proceed as in Gaussian elimination, but store negative multipliers:

$$
\left[\begin{array}{rrr}
(2) & 1 & 0 \\
-2 & 0 & -1 \\
2 & 3 & -3
\end{array}\right] \xrightarrow[E_{31}(-1)]{E_{21}(1)}\left[\begin{array}{rrr}
2 & 1 & 0 \\
-1 & (1) & -1 \\
1 & 2 & -3
\end{array}\right] \xrightarrow[E_{32}(-2)]{\longrightarrow}\left[\begin{array}{rrr}
2 & 1 & 0 \\
-1 & 1 & -1 \\
1 & 2 & -1
\end{array}\right] .
$$

Now we read off the results from the last matrix:

$$
L=\left[\begin{array}{rrr}
1 & 0 & 0 \\
1 & 1 & 0 \\
-1 & 2 & 1
\end{array}\right] \text { and } U=\left[\begin{array}{rrr}
2 & 1 & 0 \\
0 & 1 & -1 \\
0 & 0 & -1
\end{array}\right]
$$

What can be said if row exchanges are required (for example, we might want to use a partial pivoting strategy)? Take the point of view that we could see our way to the end of Gaussian elimination and store the product $P$ of all row-exchanging elementary operations that we use Permutation Matrix along the way. A product of such matrices is called a permutation matrix; such a matrix is invertible, since it is a product of invertible matrices. Thus, if we apply the correct permutation matrix $P$ to $A$ we obtain a matrix for which Gaussian elimination will succeed without further row exchanges. Consequently, we have a theorem that applies to all nonsingular matrices. Notice that it does not limit the usefulness of LU factorization since the linear system $A x=b$ is equivalent to the system $P A x=P b$. The following theorem could be called the "PLU factorization theorem."

Theorem 2.14. If $A$ is a nonsingular matrix, then there exists a permutation matrix $P$, upper triangular matrix $U$, and unit lower triangular matrix $L$ such that $P A=L U$.
-->
<section id="lu-factorization" class="level1">
<h1><em>LU Factorization</em></h1>
<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section"><em></em></h2>
<p>Suppose we want to solve a nonsingular linear system <span class="math inline">\(A x=b\)</span> repeatedly, with different choices of <span class="math inline">\(b\)</span>.</p>
<p>. . .</p>
<p>E.g. Heat flow problem, where the right-hand side is determined by the heat source term <span class="math inline">\(f(x)\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://cdn.mathpix.com/cropped/2024_02_16_adbe27593182d62240abg-017.jpg?height=411&amp;width=612&amp;top_left_y=508&amp;top_left_x=453" class="lightbox" data-gallery="quarto-lightbox-gallery-1" data-glightbox="description: .lightbox-desc-1" title="Discrete approximation to temperature function (n=5)"><img src="https://cdn.mathpix.com/cropped/2024_02_16_adbe27593182d62240abg-017.jpg?height=411&amp;width=612&amp;top_left_y=508&amp;top_left_x=453" class="img-fluid figure-img" alt="Discrete approximation to temperature function (n=5)"></a></p>
<figcaption>Discrete approximation to temperature function <span class="math inline">\((n=5)\)</span></figcaption>
</figure>
</div>
<p><span class="math display">\[
\begin{equation*}
-y_{i-1}+2 y_{i}-y_{i+1}=\frac{h^{2}}{K} f\left(x_{i}\right), i=1,2, \ldots, n
\end{equation*}
\]</span></p>
<p>. . .</p>
<p>Perhaps you want to experiment with different functions for the heat source term.</p>
<p>. . .</p>
<p>What do we do? Each time, we create the augmented matrix <span class="math inline">\(\widetilde{A}=[A \mid b]\)</span>, then get it into reduced row echelon form.</p>
<p>If we change <span class="math inline">\(b\)</span>, we have to redo all the work of Gaussian or Gauss-Jordan elimination each time!</p>
<p>. . .</p>
<p>Especially frustrating because the main part of our work is the same: putting the part of <span class="math inline">\(\widetilde{A}\)</span> corresponding to the coefficient matrix <span class="math inline">\(A\)</span> into reduced row echelon form.</p>
</section>
<section id="lu-factorization-saving-that-work" class="level2">
<h2 class="anchored" data-anchor-id="lu-factorization-saving-that-work"><em>LU Factorization: Saving that work</em></h2>
<p>Goal: Find a way to record our work on <span class="math inline">\(A\)</span>, so that solving a new system involves very little additional work.</p>
<div class="definition">
<p>LU Factorization: Let <span class="math inline">\(A\)</span> be an <span class="math inline">\(n \times n\)</span> matrix. An LU factorization of <span class="math inline">\(A\)</span> is a pair of <span class="math inline">\(n \times n\)</span> matrices <span class="math inline">\(L, U\)</span> such that</p>
<ol type="1">
<li><span class="math inline">\(L\)</span> is lower triangular.</li>
<li><span class="math inline">\(U\)</span> is upper triangular.</li>
<li><span class="math inline">\(A=L U\)</span>.</li>
</ol>
</div>
<p>. . .</p>
<p>Why is this so wonderful? Triangular systems <span class="math inline">\(A \mathbf{x}=\mathbf{b}\)</span> are easy to solve.</p>
<p>Remember: If <span class="math inline">\(A\)</span> is upper triangular, we can solve for the last variable, then the next-to-last variable, etc.</p>
</section>
<section id="solving-an-upper-triangular-system" class="level2">
<h2 class="anchored" data-anchor-id="solving-an-upper-triangular-system"><em>Solving an upper triangular system</em></h2>
<p>Let’s say we have the following system:</p>
<span class="math display">\[ A x = b \]</span> where A is the upper-triangular matrix $ A =
<span class="math display">\[\begin{bmatrix} 2 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; -1 \\ 0 &amp; 0 &amp; -1 \end{bmatrix}\]</span>
<p>$, and we want to solve for <span class="math inline">\(b = \begin{bmatrix} 1 \\ 1 \\ -2 \end{bmatrix}\)</span>.</p>
<p>We form the augmented matrix <span class="math inline">\(\widetilde{A} = [A | b] = \begin{bmatrix} 2 &amp; 1 &amp; 0 &amp; | &amp; 1 \\ 0 &amp; 1 &amp; -1 &amp; | &amp; 1 \\ 0 &amp; 0 &amp; -1 &amp; | &amp; -2 \end{bmatrix}\)</span>.</p>
<p>Back substitution: 1. Last equation: <span class="math inline">\(-x_3 = -2\)</span>, so <span class="math inline">\(x_3 = 2\)</span>. 2. Substitute this value into the second equation, <span class="math inline">\(x_2 - x_3 = 1\)</span>, so <span class="math inline">\(x_2 = 3\)</span>. 3. Finally, we substitute <span class="math inline">\(x_2\)</span> and <span class="math inline">\(x_3\)</span> into the first equation, <span class="math inline">\(2x_1 + x_2 = 1\)</span>, so <span class="math inline">\(x_1 = -1\)</span>.</p>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">Discrete approximation to temperature function <span class="math inline">\((n=5)\)</span></span>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"openEffect":"zoom","loop":false,"closeEffect":"zoom","selector":".lightbox","descPosition":"bottom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>