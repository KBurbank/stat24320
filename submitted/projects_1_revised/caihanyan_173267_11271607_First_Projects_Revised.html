<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Stat 24320</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<div id="a159c000" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>#Markov Chain</p>
<p>The transition matrix under this context will be</p>
<p><span class="math display">\[
\begin{bmatrix}
0.5 &amp; 0.2 &amp; 0.3\\
0.2 &amp; 0.6 &amp; 0.1\\
0.3 &amp; 0.2 &amp; 0.6\\
\end{bmatrix}
\]</span> .</p>
<p>Now, let us put this transition matrix into code. We will set the initial state of the system to be <span class="math display">\[
\begin{bmatrix}
\frac{1}{3}\\
\frac{1}{3}\\
\frac{1}{3}
\end{bmatrix}
\]</span></p>
<p>to denote all three companies having equal shares of the market.</p>
<div id="26a7f759" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Code in this transition matrix and the initial state (Equal shares of customers)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>markovTransition <span class="op">=</span> np.array([[<span class="fl">0.5</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>], [<span class="fl">0.2</span>, <span class="fl">0.6</span>, <span class="fl">0.1</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.6</span>]])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>initialState <span class="op">=</span> np.array([[<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>], [<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>], [<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>]])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>iteration <span class="op">=</span> initialState</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Test three iterations</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  iteration <span class="op">=</span> markovTransition.dot(iteration)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> Year Later: </span><span class="ch">\n</span><span class="ss"> Percent of customer shares for A: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(iteration[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">*</span> <span class="dv">100</span>, decimals<span class="op">=</span><span class="dv">2</span>)<span class="sc">}</span><span class="ss">% </span><span class="ch">\n</span><span class="ss"> Percent of customer shares for B: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(iteration[<span class="dv">1</span>, <span class="dv">0</span>] <span class="op">*</span> <span class="dv">100</span>, decimals<span class="op">=</span><span class="dv">2</span>)<span class="sc">}</span><span class="ss">% </span><span class="ch">\n</span><span class="ss"> Percent of customer shares for C: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(iteration[<span class="dv">2</span>, <span class="dv">0</span>] <span class="op">*</span> <span class="dv">100</span>, decimals<span class="op">=</span><span class="dv">2</span>)<span class="sc">}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1 Year Later: 
 Percent of customer shares for A: 33.33% 
 Percent of customer shares for B: 30.0% 
 Percent of customer shares for C: 36.67%
2 Year Later: 
 Percent of customer shares for A: 33.67% 
 Percent of customer shares for B: 28.33% 
 Percent of customer shares for C: 38.0%
3 Year Later: 
 Percent of customer shares for A: 33.9% 
 Percent of customer shares for B: 27.53% 
 Percent of customer shares for C: 38.57%</code></pre>
</div>
</div>
<p>We can see from the results that B begins to lose shares of the market, C gains a considerable amount of shares (around 2%), while A gains small amount of shares (around 0.6%) in three years.</p>
<p>Now, let us test the effects of the two advertising campaigns.</p>
<p>Advertising Campaign 1 convinces 20% of customers who would have to stay in B to switch to A. This can be represented in the modified transition matrix: <span class="math display">\[
\begin{bmatrix}
0.5 &amp; 0.32 &amp; 0.3\\
0.2 &amp; 0.48 &amp; 0.1\\
0.3 &amp; 0.2 &amp; 0.6\\
\end{bmatrix}
\]</span></p>
<p>Advertising Campaign 2 convinces 20% of customers who would have to stay in C to switch to A. This can be represented in the modified transition matrix:</p>
<p><span class="math display">\[
\begin{bmatrix}
0.5 &amp; 0.2 &amp; 0.42\\
0.2 &amp; 0.6 &amp; 0.1\\
0.3 &amp; 0.2 &amp; 0.48\\
\end{bmatrix}
\]</span></p>
<p>To view the effectiveness of the campaigns, I will iterate these markov chains over times and create a Gaussian Fit.</p>
<div id="92b5f511" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Code in the advertising campaign transition matrices.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>transition1 <span class="op">=</span> np.array([[<span class="fl">0.5</span>, <span class="fl">0.32</span>, <span class="fl">0.3</span>], [<span class="fl">0.2</span>, <span class="fl">0.48</span>, <span class="fl">0.1</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.6</span>]])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>transition2 <span class="op">=</span> np.array([[<span class="fl">0.5</span>, <span class="fl">0.2</span>, <span class="fl">0.42</span>], [<span class="fl">0.2</span>, <span class="fl">0.6</span>, <span class="fl">0.1</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.48</span>]])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us iterate over random distribution vectors for the two transition matrices</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># to view the resulting market shares after 3 years, 50 years, and 100 years.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">10</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>runs <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># I am defining a function that takes in the two transition matrices and the</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># number of years to iterate and outputs Gaussian fits for the shares for A</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> advertisingGaussian(runs, years, transitionMatrix1, transitionMatrix2):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  resultForAFrom1 <span class="op">=</span> []</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  resultForAFrom2 <span class="op">=</span> []</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> run <span class="kw">in</span> <span class="bu">range</span>(runs):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We do experiment a total of variable "runs" times.</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create random initial distribution vector for the intial market share.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    mold <span class="op">=</span> np.random.random((<span class="dv">3</span>,))</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    initialState <span class="op">=</span> mold <span class="op">/</span> mold.<span class="bu">sum</span>()</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> initialState</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now we do the actual iteration for the two matrices and append the results.</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(years):</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>      state <span class="op">=</span> transition1.dot(state)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    resultForAFrom1.append(state[<span class="dv">0</span>])</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> initialState</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(years):</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>      state <span class="op">=</span> transition2.dot(state)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    resultForAFrom2.append(state[<span class="dv">0</span>])</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Now we can fit the two sets of data for the market share of A</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">6</span>))</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Determine the random color of the histograms</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>  randomColorNumber <span class="op">=</span> np.random.rand(<span class="dv">3</span>,)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Fitting the 1 results</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>  mu1, sigma1 <span class="op">=</span> norm.fit(resultForAFrom1)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Plotting the advertising campaign 1 results</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">0</span>].hist(resultForAFrom1, bins<span class="op">=</span><span class="dv">100</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span>randomColorNumber)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">0</span>].set_title(<span class="ss">f'The Distribution of Market Shares of A with Advertising Campaign 1 after </span><span class="sc">{</span>years<span class="sc">}</span><span class="ss"> years, iterated for </span><span class="sc">{</span>runs<span class="sc">}</span><span class="ss"> times.</span><span class="ch">\n</span><span class="ss">(Estimated market share value of A for Campaign 1: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(mu1, decimals<span class="op">=</span><span class="dv">4</span>)<span class="sc">}</span><span class="ss">)'</span>, pad<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">0</span>].set_xlabel(<span class="st">'Market Share Distribution for A'</span>)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">0</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>  xmin1, xmax1 <span class="op">=</span> axs[<span class="dv">0</span>].get_xlim()</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>  x1 <span class="op">=</span> np.linspace(xmin1, xmax1, <span class="dv">100</span>)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>  p1 <span class="op">=</span> norm.pdf(x1, mu1, sigma1)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">0</span>].plot(x1, p1, <span class="st">'k'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Gaussian Fit'</span>)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Fitting the 2 results</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>  mu2, sigma2 <span class="op">=</span> norm.fit(resultForAFrom2)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Plotting the advertising campaign 2 results</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">1</span>].hist(resultForAFrom2, bins<span class="op">=</span><span class="dv">100</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span>randomColorNumber)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">1</span>].set_title(<span class="ss">f'The Distribution of Market Shares of A with Advertising Campaign 2 after </span><span class="sc">{</span>years<span class="sc">}</span><span class="ss"> years, iterated for </span><span class="sc">{</span>runs<span class="sc">}</span><span class="ss"> times.</span><span class="ch">\n</span><span class="ss">(Estimated market share value of A for Campaign 2: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(mu2, decimals<span class="op">=</span><span class="dv">4</span>)<span class="sc">}</span><span class="ss">)'</span>, pad<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">1</span>].set_xlabel(<span class="st">'Market Share Distribution for A'</span>)</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>  xmin2, xmax2 <span class="op">=</span> axs[<span class="dv">1</span>].get_xlim()</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>  x2 <span class="op">=</span> np.linspace(xmin2, xmax2, <span class="dv">100</span>)</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>  p2 <span class="op">=</span> norm.pdf(x2, mu2, sigma2)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>  axs[<span class="dv">1</span>].plot(x2, p2, <span class="st">'k'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Gaussian Fit'</span>)</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Showing the plot</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>  plt.tight_layout()</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>  plt.show()</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Now call the function</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>advertisingGaussian(runs, <span class="dv">3</span>, transition1, transition2)</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>advertisingGaussian(runs, <span class="dv">10</span>, transition1, transition2)</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>advertisingGaussian(runs, <span class="dv">50</span>, transition1, transition2)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>advertisingGaussian(runs, <span class="dv">100</span>, transition1, transition2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="caihanyan_173267_11271607_First_Projects_Revised_files/figure-html/cell-4-output-1.png" width="878" height="567" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>




</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="caihanyan_173267_11271607_First_Projects_Revised_files/figure-html/cell-4-output-3.png" width="888" height="567" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/kendra/Library/Python/3.8/lib/python/site-packages/numpy/lib/histograms.py:883: RuntimeWarning: divide by zero encountered in divide
  return n/db/n.sum(), bin_edges
/Users/kendra/Library/Python/3.8/lib/python/site-packages/numpy/lib/histograms.py:883: RuntimeWarning: invalid value encountered in divide
  return n/db/n.sum(), bin_edges</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="caihanyan_173267_11271607_First_Projects_Revised_files/figure-html/cell-4-output-5.png" width="888" height="567" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="caihanyan_173267_11271607_First_Projects_Revised_files/figure-html/cell-4-output-6.png" width="899" height="567" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Let us analyze these results. Each pair of histogram denotes the distribution of the market shares for A after some years. The estimated market share values after the set amount of years is denoted under the title. This estimated value is the mu parameter for the Gaussian fit, denoting the value with the greatest probabiltiy distribution.</p>
<p>For Advertising Campaign 1, we see that for 1000 random initial distributions of market shares will tend with each iteration towards a stationary state of 0.38 for the market share of A. This suggests that Advertising Campaign 1 will allow A to stabilize at 0.3806 marketshares. This seems to be a very good strategy.</p>
<p>For Advertising Campaign 2, we can see that the most probable market share distribution for also increases. With long iterations under numerous random intial states, A seems to always achieve the stationary state of 0.39 for its market share.</p>
<p>Even after three years, markov simulation suggests that Advertising Campaign 2 performs better than Advertising Campaign 1, as the market share of A under Advertising Campaign 2 is bigger than the market share of A under Advertising Campaign 1. The later iterations also suggests the same thing. Therefore, my model suggests that Advertising Campaign 2 is a more effective choice both for long term and short term increase in market share for A.</p>
<p>It is important to note the limitations within this model. First, it simplifies the dynamics of the market. By iterating the static transition matrices over long periods of time, we are assuming that the market does not change. In other words, company B and company C are doing nothing to regain their lost customers. After all, it is quite unreasonable to assume that things will always stay the same in 100 years. The effectiveness of the advertising campaign also can change, which is not reflected in the static transition matrices. Therefore, this model may be effect in approximating the effects of the advertising campaigns for a very short period of iteration before competitors B and C have a chance to react or implement their own strategies.</p>
<blockquote class="blockquote">
<p>Revision: In addition, by looking at the initial transition matrices:</p>
</blockquote>
<p><span class="math display">\[
\begin{bmatrix}
0.5 &amp; 0.32 &amp; 0.3\\
0.2 &amp; 0.48 &amp; 0.1\\
0.3 &amp; 0.2 &amp; 0.6\\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}
0.5 &amp; 0.2 &amp; 0.42\\
0.2 &amp; 0.6 &amp; 0.1\\
0.3 &amp; 0.2 &amp; 0.48\\
\end{bmatrix}
\]</span></p>
<p>We can see that every iteration, A is obtaining the same percent of customers from B and C, in the first advertisement matrix, C is obtaining more customers than B. This allows C to stay competitive with A, competing for the shares of B, as opposed to the second advertisement matrix, which makes C less competitive, allowing for A to dominate more equally to A and B.</p>
<blockquote class="blockquote">
<p>It is also worth noting the issue with the histogram. It seems like after 50 years, the stationary state is almost reached despite random initial states, resulting in all possible data contributing to one box of the histogram. I do not know exactly how I should fix this though. Perhaps I should stop after 20 years.</p>
</blockquote>
<div class="comments">
<p>I agree that the histogram isn’t so useful when all of the data is concentrated in one bin! But that’s not a problem, per se – your data just gets to the stationary state.</p>
</div>
<p>Now, perhaps we wish to go a step further and analyze how much of an effect gaining shares from B or C will have on the long term share of A. Then, we can simply construct functions of A market share with respect to the gaining of the market share of B or C.</p>
<div id="c369c25b" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The variable parameter will be a number between 0 and 1, denoting up till</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 100% of the customer that was suppose to remain with B going to A</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterations will control how many years passes.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> functionB(parameter, iterations, initialState):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  change <span class="op">=</span> parameter <span class="op">*</span> <span class="fl">0.4</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  transitionMatrix <span class="op">=</span> np.array([[<span class="fl">0.5</span>, <span class="fl">0.2</span> <span class="op">+</span> change, <span class="fl">0.3</span>], [<span class="fl">0.2</span>, <span class="fl">0.6</span> <span class="op">-</span> change, <span class="fl">0.1</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.6</span>]])</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We will start with the assumption for equal shares.</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    initialState <span class="op">=</span> transitionMatrix.dot(initialState)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> initialState[<span class="dv">0</span>]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> functionC(parameter, iterations, initialState):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  change <span class="op">=</span> parameter <span class="op">*</span> <span class="fl">0.4</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  transitionMatrix <span class="op">=</span> np.array([[<span class="fl">0.5</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span> <span class="op">+</span> change], [<span class="fl">0.2</span>, <span class="fl">0.6</span>, <span class="fl">0.1</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.6</span> <span class="op">-</span> change]])</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We will start with the assumption for equal shares</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    initialState <span class="op">=</span> transitionMatrix.dot(initialState)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> initialState[<span class="dv">0</span>]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting the initial state to be all companies having equal shares</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>initialState <span class="op">=</span> np.ones((<span class="dv">3</span>,<span class="dv">1</span>)) <span class="op">/</span> <span class="dv">3</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Readying the plot</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>xValues <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>, num<span class="op">=</span><span class="dv">101</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>BValues <span class="op">=</span> []</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>CValues <span class="op">=</span> []</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> xValues:</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>  BValues.append(functionB(x, <span class="dv">50</span>, initialState))</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>  CValues.append(functionC(x, <span class="dv">50</span>, initialState))</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Market Share of A after 50 years with Respect to Change in Parameter x"</span>)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>plt.plot(xValues, BValues, label<span class="op">=</span><span class="st">"Parameter under Advertisement 1 (B to A)"</span>)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>plt.plot(xValues, CValues, label<span class="op">=</span><span class="st">"Parameter under Advertisement 2 (C to A)"</span>)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Parameter (Percent Change / 100)"</span>)</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Market Share for A"</span>)</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"upper left"</span>, frameon<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="caihanyan_173267_11271607_First_Projects_Revised_files/figure-html/cell-5-output-1.png" width="626" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The above graph works is generated by the following method. We introduce the parameter variable that ranges from 0 to 1. For each transition matrix representing the advertisement matrix, the parameter looks at the percentage of customers going to A rather than staying in B/C from the effects of the campaign and multiplies it by the parameter. For example, if the parameter is 1, than for Advertisement 1, 100% of the customers that was originally going to stay with B will go to A, resulting in the following transition matrix: <span class="math inline">\(\begin{bmatrix}
0.5 &amp; 0.8 &amp; 0.3\\
0.2 &amp; 0.0 &amp; 0.1\\
0.3 &amp; 0.2 &amp; 0.6\\
\end{bmatrix}\)</span>.</p>
Now, with the modified transition matrix by the parameter, the initial state of all companies having equal shares
<span class="math display">\[\begin{bmatrix}
\frac{1}{3}\\
\frac{1}{3}\\
\frac{1}{3}
\end{bmatrix}\]</span>
<p>is initialized. We apply the initial state to the modified transition matrix for 50 times. The resulting market share value of A is then recorded and plotted.</p>
<p>Looking at the graph, if the resources needed to convert customers from C to A is the same as the resources needed to convert customers from B to A, then it is more effective to convert customers from C since the increase in the market share of A is more for C than B as we increase the parameter.</p>
<p>#Sports Ranking</p>
<p>We will first rank the Teams based on their win-loss ratio.</p>
<blockquote class="blockquote">
<p>Revision: It is not the win-loss ratio, but simply the difference between the number of wins and losses for each Team.</p>
</blockquote>
<p>This will be the simplest way to rank them. In fact, we can create a digraph with the given edges before doing so. This allows us to create an adjacency matrix. The sum of the <span class="math inline">\(i^{th}\)</span> row of the matrix gives us the number of wins for Team <span class="math inline">\(i\)</span>, while the sum of the <span class="math inline">\(i^{th}\)</span> column of the matrix gives us the number of losses for Team <span class="math inline">\(i\)</span>. Therefore, to account for both wins and losses of each Team, we can create a ranking score for each Team determined by their number of wins subtracted by their number of losses. Using the adjacency matrix of the graph we created makes our life a lot easier, so I am introducing the graph before the simple ranking.</p>
<div id="1a4f257c" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>sportsGraph <span class="op">=</span> nx.DiGraph()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>sportsGraph.add_nodes_from([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>])</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">7</span>, <span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">3</span>, <span class="dv">2</span>), (<span class="dv">5</span>, <span class="dv">1</span>), (<span class="dv">6</span>, <span class="dv">1</span>), (<span class="dv">7</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">6</span>),</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">7</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">7</span>), (<span class="dv">6</span>, <span class="dv">4</span>), (<span class="dv">3</span>, <span class="dv">5</span>), (<span class="dv">5</span>, <span class="dv">6</span>), (<span class="dv">7</span>, <span class="dv">1</span>), (<span class="dv">5</span>, <span class="dv">2</span>), (<span class="dv">7</span>, <span class="dv">6</span>),</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">4</span>), (<span class="dv">6</span>, <span class="dv">3</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>sportsGraph.add_edges_from(edges)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us plot the graph representing the wins and losses of the 7 Teams.</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>nx.draw_circular(sportsGraph, with_labels<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># To calculate the win-losses for the Teams, we can do it by hand, but it is easier to analyze the adjacency matrix of the graph.</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>adj_matrix <span class="op">=</span> nx.adjacency_matrix(sportsGraph)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>adj_matrix <span class="op">=</span> adj_matrix.toarray()</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the win and loss arrays, where the index+1 denotes the Team number:</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>wins <span class="op">=</span> np.zeros(<span class="dv">7</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>losses <span class="op">=</span> np.zeros(<span class="dv">7</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co"># The ith column of the adjacency matrix is the number of losses Team i experienced. The ith row is the number of wins Team i experienced.</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(wins)):</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>  wins[i] <span class="op">=</span> adj_matrix[i,:].<span class="bu">sum</span>()</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(losses)):</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>  losses[i] <span class="op">=</span> adj_matrix[:, i].<span class="bu">sum</span>()</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="co"># We define a very simple score that takes into account the number of wins and the number of losses for each Team. The higher the winLossScore, the better the ranking.</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>winLossScore <span class="op">=</span> wins <span class="op">-</span> losses</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>simpleSort <span class="op">=</span> np.argsort(winLossScore)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>wLSorted <span class="op">=</span> np.sort(winLossScore)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Simple ranking of the Teams based on win/loss:"</span>)</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(simpleSort)):</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Team </span><span class="sc">{</span>simpleSort[i] <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> with a win - loss score of </span><span class="sc">{</span>wLSorted[i]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="caihanyan_173267_11271607_First_Projects_Revised_files/figure-html/cell-6-output-1.png" width="691" height="499" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>

Simple ranking of the Teams based on win/loss:
1: Team 7 with a win - loss score of 4.0
2: Team 5 with a win - loss score of 2.0
3: Team 3 with a win - loss score of 1.0
4: Team 6 with a win - loss score of 0.0
5: Team 1 with a win - loss score of -1.0
6: Team 2 with a win - loss score of -2.0
7: Team 4 with a win - loss score of -4.0</code></pre>
</div>
</div>
<p>We can see that the win-loss score gives us fairly neat ranking. Although we didn’t see the same scores on different Teams, we can account for it by developing a system. If two Teams have the same score, then we look at their total wins. The Team with the most wins will be ranked higher. If they have the same wins, they have to have the same losses (since they have the same win-loss score).</p>
<blockquote class="blockquote">
<p>Revision: If two Teams have the same win-loss difference and they have the same number of wins, then they must have the same number of losses. For instance, if Team 1 and Team 2 both have a win-loss difference of 2 and they both won 5 games, then they both must have lost 3 games. Then, there is no value comparing the number of losses of Team 1 and Team 2. Then, if we are under the situation where two Teams has the same win-loss difference and the same number of wins, we cannot really distinguish their ranking. Instead, we should look for a better way to rank.</p>
</blockquote>
<p>In this case, we will have to devise more sophisticated methods for ranking. This is what we do next. We will use the vertex power to rank the Teams. Remember, the vertex power is the number of connections of a vertex with length two of less. This allows us to sort of consider the “weight” of the Team wins. If Team 1 wins Team 2, and Team 2 wins Team 3, then we consider Team 1 to be better than Team 3 and count that as a “win” for Team 1 (lucky!)</p>
<p>Then, we can rank the Teams based on this power concept. The Team with the highest power will be first place.</p>
<div id="f4cc5c70" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Next, we use the vertex power to rank</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the power matrix</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>powerMatrix <span class="op">=</span> adj_matrix <span class="op">+</span> adj_matrix.dot(adj_matrix)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># This will include all values for the powers of each Team i (index)</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>powers <span class="op">=</span> np.zeros(<span class="dv">7</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(powers)):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  powers[i] <span class="op">=</span> powerMatrix[i, :].<span class="bu">sum</span>()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, sort the powers</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>powerSort <span class="op">=</span> np.argsort(powers)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>powersSorted <span class="op">=</span> np.sort(powers)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the sort</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Power Ranking of the Teams"</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(powerSort)):</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Team </span><span class="sc">{</span>powerSort[i] <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> with a power value of </span><span class="sc">{</span>powersSorted[i]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Power Ranking of the Teams
1: Team 7 with a power value of 16.0
2: Team 5 with a power value of 16.0
3: Team 3 with a power value of 10.0
4: Team 6 with a power value of 9.0
5: Team 2 with a power value of 6.0
6: Team 4 with a power value of 5.0
7: Team 1 with a power value of 5.0</code></pre>
</div>
</div>
<p>We can see that, compared to the simple ranking based on win-loss scores, the power ranking has all of the places the same except for a switch in the place of Team 1, 2, 4. This is interesting. This means that although Team 2 has a lower win-loss score than Team 1, it has a higher power than Team 1. We also note that the power ranking is not satisfactory, as there are two pairs of Teams (7 and 5, 4 and 1) that has the same power.</p>
<blockquote class="blockquote">
<p>Revision: Let us look at the reason why Team 2 has higher power than Team 1, even though Team 1 won more games than Team 2. Team 1 won 2 games. One is against Team 2 and another against Team 4. Team 2 won 2 game. One is against Team 6 and another against Team 4. To calculate the power of the Team in quesiton, we have to also count the number of Teams that the losing Team to the Team in question won. This is what causes the change. Team 2 and Team 4 won a total of 3 games. So the power of Team 1 is 2 (victories of Team 1) + 3 = 5. However, Team 2 won a game against Team 6 (sheer luck?), which won 3 games. Team 4 won 1 games. Therefore, Team 2 will have a score of 2 + 4 = 6, resulting in a higher power than Team 1. Thinking about this intuitively, we are basically incorporating a very simple weighting to the victories. Team 2’s victory against Team 6 is much more valuable than any of the Team 1’s victories because Team 6 is a powerful Team that had won a lot of games. Team 1’s victories against 4 and 2 is not really impressive, since they rarely win.</p>
</blockquote>
<div class="comments">
<p>Yup, you’ve got it!</p>
</div>
<p>Therefore, we should go further and try the Reverse PageRank method. Remember that the Reverse PageRank uses the adjoint of our original adjacency matrix. So, instead of the original PageRank ranking pages based on ingoing links, we now rank based on outgoing links. In our context, this is what we wish, since the outgoing links from Team 1 to Team 2 means that Team 1 won over Team 2. Also, Reverse PageRank involves the inclusion of a teleportation vector. This teleportation vector in this context allows us to encode in some “luck” parameter to all of the Teams. Maybe Team 1 won Team 2 because a member in Team 2 had a stomache. The teleportation vector then represents a global correction to the weighing of all wins.</p>
<blockquote class="blockquote">
<p>Revision: Let us further explain this teleportation vector. In the graph context, by including this normalized teleportation vector, we are applying a normalized “path” that allows every node to reach every node. In our context, we are sort of saying that each Team “won” every other Team! With the alpha parameter, we make this “win” weigh much less than the real edges (scores). By adding these “universal” victories, we are giving every Team a bit of slack. By controlling the parameter alpha according, which controls how much influence the teleportation vector has on the transition matrix, we are controlling how the Teams differ in skill! If we make the teleportaion vector weigh more by decreasing the alpha parameter, then we are saying that the Teams are more equal in skill. Under this case, then the actual scores will weigh less, meaning that the actual wins and losses for each Team will be because of factor of luck or other external factors.</p>
</blockquote>
<p>Now, let’s do the reverse pagerank.</p>
<div id="a8281db9" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>transitionMatrix <span class="op">=</span> np.zeros(np.shape(adj_matrix))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Since we are doing the transpose of the adjacent matrix, we can do a small</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># shortcut and simply normalize the column vectors of the adjacement matrix.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># This is because the transition matrix is the "normalized" transpose of the</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"># adjacent matrix. We start with the transpose of the adjacent matrix. So this</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ends up canceling out.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(np.shape(adj_matrix)[<span class="dv">1</span>]):</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  sumBuffer <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(np.shape(adj_matrix)[<span class="dv">0</span>]):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    sumBuffer <span class="op">+=</span> adj_matrix[i,j]</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(np.shape(adj_matrix)[<span class="dv">0</span>]):</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> adj_matrix[m,j] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>      transitionMatrix[m,j] <span class="op">=</span> adj_matrix[m,j] <span class="op">/</span> sumBuffer</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, we solve the PageRank equation with our obtained transitionMatrix</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.85</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>matrixToSolve <span class="op">=</span> np.eye(<span class="dv">7</span>) <span class="op">-</span> alpha <span class="op">*</span> transitionMatrix</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>inverse <span class="op">=</span> np.linalg.inv(matrixToSolve)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>oneMinusAlphaV <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> alpha) <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">7</span> <span class="op">*</span> np.ones((<span class="dv">7</span>,<span class="dv">1</span>)))</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>answer <span class="op">=</span> inverse.dot(oneMinusAlphaV)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="co">#Now we sort the values based on descending order</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>reverseIndex <span class="op">=</span> np.argsort(answer, axis<span class="op">=</span><span class="dv">0</span>).flatten()[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>reverseSort <span class="op">=</span> np.sort(answer, axis<span class="op">=</span><span class="dv">0</span>).flatten()[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="co">#Printing the results</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The ReversePage Algorithm Ranking: "</span>)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(answer)):</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Team </span><span class="sc">{</span>reverseIndex[i] <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> with the value of </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(reverseSort[i], decimals<span class="op">=</span><span class="dv">2</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The ReversePage Algorithm Ranking: 
1: Team 5 with the value of 0.25
2: Team 7 with the value of 0.18
3: Team 3 with the value of 0.17
4: Team 6 with the value of 0.13
5: Team 4 with the value of 0.13
6: Team 2 with the value of 0.08
7: Team 1 with the value of 0.06</code></pre>
</div>
</div>
<p>Let us think about the results of this ReversePage compared to the power ranking. We can see now that when we consider the “stable state”, which is what we determine to be the ranking, Team 5 has higher “ranking score” than Team 7. This suggests that even though Team 5 and Team 7 have the same power, the influence, or the “quality” of the wins for Team 5 is higher than Team 7.</p>
<blockquote class="blockquote">
<p>Revision: Let us look at why the “quality” of the wins for Team 5 is higher than Team 7. Simply put, Team 5 won against Team 7 but Team 7 didn’t win against Team 5. In the reversePageRank context, the outgoing links of the Team 5 nodes is much more valuable than the outgoing links of the Team 7 node. Therefore, solving for the reversePageRank gives us a higher ranking for Team 5 then Team 7. In our context, we are claiming that even though Team 7 won more influential games than Team 5 (Power Ranking), the fact that Team 5 beat Team 7 makes Team 5 better than Team 7, so it definitely makes sence for Team 5 to be above Team 7 in ranking!</p>
</blockquote>
<p>Another interesting result to recognize is the change in the ranking place for Team 4 and Team 6. Even though the “quality” of their wins are the same, the power, or the amount of their wins differ.</p>
<p>Now, let us add actual weights to the wins with M.</p>
<div id="6bc49231" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> [<span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">7</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">23</span>, <span class="dv">15</span>, <span class="dv">6</span>, <span class="dv">18</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">7</span>, <span class="dv">13</span>, <span class="dv">7</span>, <span class="dv">18</span>, <span class="dv">45</span>, <span class="dv">10</span>, <span class="dv">19</span>, <span class="dv">14</span>, <span class="dv">13</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Administer the weighing</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>newMatrix <span class="op">=</span> np.zeros(np.shape(adj_matrix))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> coordinate <span class="kw">in</span> edges:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  newMatrix[coordinate[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, coordinate[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> adj_matrix[coordinate[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>, coordinate[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>] <span class="op">*</span> M[index]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the new power matrix</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>newPowerMatrix <span class="op">=</span> newMatrix <span class="op">+</span> newMatrix.dot(newMatrix)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># This will include all values for the powers of each Team i (index)</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>newPower <span class="op">=</span> np.zeros(<span class="dv">7</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(newPower)):</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  newPower[i] <span class="op">=</span> newPowerMatrix[i, :].<span class="bu">sum</span>()</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, sort the powers</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>newPowerSort <span class="op">=</span> np.argsort(newPower)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>newPowersSorted <span class="op">=</span> np.sort(newPower)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the sort</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Power ranking with added weighing: "</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(newPowerSort)):</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Team </span><span class="sc">{</span>newPowerSort[i] <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss"> with a power value of </span><span class="sc">{</span>newPowersSorted[i]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Power ranking with added weighing: 
1: Team 5 with a power value of 2104.0
2: Team 7 with a power value of 2089.0
3: Team 2 with a power value of 784.0
4: Team 6 with a power value of 701.0
5: Team 3 with a power value of 647.0
6: Team 4 with a power value of 177.0
7: Team 1 with a power value of 160.0</code></pre>
</div>
</div>
<p>The higher the power value for the Teams, we can assume that the significance of their win is larger. This means that we know although Team 5 had less wins than Team 7, Team 5’s wins were just so much more rewarding and meaningful. The same could be said with the other Teams.</p>
<div class="comments">
<p>You’ve got nice responses as to the “why” in each situation here – great!</p>
<p>Grade: E</p>
</div>
<p>#LU Factorization</p>
<p>Let us construct the Gaussian Elimination Algorithm and record all row exchanges with an index array. The overall idea is as follows: For a given matrix A, we first look at the first column of A and find the first nonzero component for this column vector. If this is not the first row of the column vector, we swap it with the first row of the column vector and record this swap with the index array. Then, we find all of the necessary LU factorization factors needed to make the row values of the column vector below 0, recording the multipliers in an identity matrix. Then, we move on to the 2nd column vector of A and do the same thing.</p>
<div id="7280cf83" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> PLUSystemSolver(matrix):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Converting to Numpy array</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  matrix <span class="op">=</span> np.array(matrix)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  matrixSize <span class="op">=</span> np.shape(matrix)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Define the row index vector</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  rowIndexArray <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">0</span>, matrixSize[<span class="dv">0</span>]))</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Defining the mold for the lower triangular matrix L</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  L <span class="op">=</span> np.eye(matrixSize[<span class="dv">0</span>])</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Due to the construction of the algorthm below, we need to temporary save all of the multipliers and its corresponding</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># coordinate in the L matrix. This is because we have potential row switches, which will mess the row orders up.</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  multiplierSave <span class="op">=</span> []</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  coordinateSave <span class="op">=</span> []</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Now let the algorithm begin</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We need to iterate over all column vectors</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> columnIndex <span class="kw">in</span> <span class="bu">range</span>(matrixSize[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For each column vector, iterate over the row components starting from the rowIndex as the columnIndex (indicating the diagonal)</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> rowIndexSub <span class="kw">in</span> <span class="bu">range</span>(columnIndex, matrixSize[<span class="dv">0</span>]):</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Checking for nonzero "pivots"</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (np.absolute(matrix[rowIndexArray[rowIndexSub], columnIndex]) <span class="op">&gt;</span> <span class="dv">0</span>):</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Swapping the first nonzero pivot. DON'T SWITCH THE ACTUAL ROWS</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        rowIndexArray[rowIndexArray[columnIndex]], rowIndexArray[rowIndexSub] <span class="op">=</span> rowIndexArray[rowIndexSub], rowIndexArray[rowIndexArray[columnIndex]]</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now we do the subtraction algorthm on the column. Defining the value to subtract others.</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    pivotVal <span class="op">=</span> matrix[rowIndexArray[columnIndex], columnIndex]</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We first make sure that the column index is not out of bounds (it is not the last column vector)</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> columnIndex <span class="op">!=</span> (matrixSize[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> rowIndexSub <span class="kw">in</span> <span class="bu">range</span>(columnIndex <span class="op">+</span> <span class="dv">1</span>, matrixSize[<span class="dv">0</span>]):</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If the iterated value is nonzero, we do the subtraction</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>        currentVal <span class="op">=</span> matrix[rowIndexArray[rowIndexSub], columnIndex]</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Then we do the subtraction and find the multipliers</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> currentVal <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>          multiplier <span class="op">=</span> (currentVal <span class="op">/</span> pivotVal)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>          <span class="co"># Subtracting</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>          matrix[rowIndexArray[rowIndexSub]] <span class="op">=</span> matrix[rowIndexArray[rowIndexSub]] <span class="op">-</span> (matrix[rowIndexArray[columnIndex]] <span class="op">*</span> (multiplier))</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>          <span class="co"># Recording the values of the multiplier and coordinates</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>          coordinateSave.append([rowIndexSub, columnIndex])</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>          multiplierSave.append(multiplier)</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Now we input the multipliers to the correct positions</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(coordinateSave)):</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    L[rowIndexArray[coordinateSave[i][<span class="dv">0</span>]], coordinateSave[i][<span class="dv">1</span>]] <span class="op">=</span> multiplierSave[i]</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Construction the Permutation Matrix</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>  P <span class="op">=</span> np.zeros(np.shape(matrix))</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(rowIndexArray)):</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    mold <span class="op">=</span> np.zeros(np.shape(matrix)[<span class="dv">1</span>])</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    mold[[rowIndexArray[i]]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    P[[i]] <span class="op">=</span> mold</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Finally, we switch the row position for U</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>  matrixCopy <span class="op">=</span> np.copy(matrix)</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(matrixSize[<span class="dv">0</span>]):</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>    matrix[[i]] <span class="op">=</span> matrixCopy[[rowIndexArray[i]]]</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Returning the output</span></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> P, L, matrix</span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>], [<span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">3</span>, <span class="op">-</span><span class="dv">3</span>]])</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>A2 <span class="op">=</span> np.array([[<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>],[<span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>],[<span class="dv">2</span>, <span class="dv">3</span>, <span class="op">-</span><span class="dv">3</span>]])</span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>B1 <span class="op">=</span> PLUSystemSolver(A)</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>B2 <span class="op">=</span> PLUSystemSolver(A2)</span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Starting Matrix: </span><span class="ch">\n</span><span class="st">"</span>, A)</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"P Matrix: </span><span class="ch">\n</span><span class="st">"</span>, B1[<span class="dv">0</span>])</span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"L Matrix: </span><span class="ch">\n</span><span class="st">"</span>, B1[<span class="dv">1</span>])</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"U Matrix: </span><span class="ch">\n</span><span class="st">"</span>, B1[<span class="dv">2</span>])</span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Starting Matrix: </span><span class="ch">\n</span><span class="st">"</span>, A2)</span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"P Matrix: </span><span class="ch">\n</span><span class="st">"</span>, B2[<span class="dv">0</span>])</span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"L Matrix: </span><span class="ch">\n</span><span class="st">"</span>, B2[<span class="dv">1</span>])</span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"U Matrix: </span><span class="ch">\n</span><span class="st">"</span>, B2[<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting Matrix: 
 [[ 2  1  0]
 [-4 -1 -1]
 [ 2  3 -3]]
P Matrix: 
 [[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
L Matrix: 
 [[ 1.  0.  0.]
 [-2.  1.  0.]
 [ 1.  2.  1.]]
U Matrix: 
 [[ 2  1  0]
 [ 0  1 -1]
 [ 0  0 -1]]


Starting Matrix: 
 [[ 2  1  3]
 [-4 -2 -1]
 [ 2  3 -3]]
P Matrix: 
 [[1. 0. 0.]
 [0. 0. 1.]
 [0. 1. 0.]]
L Matrix: 
 [[ 1.  0.  0.]
 [ 1.  1.  0.]
 [-2.  0.  1.]]
U Matrix: 
 [[ 2  1  3]
 [ 0  2 -6]
 [ 0  0  5]]</code></pre>
</div>
</div>
<p>We have successfully implemented the PLU function. This function takes the matrix in question and returns a tuple of (P matrix, L matrix, U matrix). We can see its success in finding the PLU matrices for HW3 Problem 12 and Problem 13.</p>
<p>Now, let us implement the module that uses this PLU function to solve general linear systems. We will assume that the diagonals for the upper triangular and lower triangular matrices are nonzero. This systemSolver algorithm will take in the square nonsingular matrix and b in the form of a list with the correct dimension (3 numbers in a list for a 3 by 3 nonsingular square matrix).</p>
<div id="b4c77e70" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us first define an upper triangular system solver.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co"># b will be a one dimensional array.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> upperSolve(matrix, b):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We are assuming that the matrix input is an upper triangular matrix.</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># The matrix has to be square, so the size we can just get a single number.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  matrixSize <span class="op">=</span> np.shape(matrix)[<span class="dv">0</span>]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Construct an empty solution vector</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  solution <span class="op">=</span> np.zeros(matrixSize)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We iterate in the reverse order on the rows</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> rowIndex <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(matrixSize)):</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The value pointer is the value of the diagonal.</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    valuePointer <span class="op">=</span> matrix[rowIndex, rowIndex]</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rowIndex <span class="op">==</span> matrixSize <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>      solution[matrixSize <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> b[matrixSize <span class="op">-</span> <span class="dv">1</span>] <span class="op">/</span> valuePointer</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    solution[rowIndex] <span class="op">=</span> b[rowIndex] <span class="op">/</span> matrix[rowIndex, rowIndex]</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(rowIndex <span class="op">+</span> <span class="dv">1</span>, matrixSize):</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>      solution[rowIndex] <span class="op">-=</span> matrix[rowIndex, index] <span class="op">*</span> solution[index] <span class="op">/</span> matrix[rowIndex, rowIndex]</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> solution</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lowerSolve(matrix, b):</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># This will be similar to the upperSolve algorithm</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We are assuming that the matrix input is an upper triangular matrix.</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># The matrix has to be square, so the size we can just get a single number.</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>  matrixSize <span class="op">=</span> np.shape(matrix)[<span class="dv">0</span>]</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Construct an empty solution vector</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>  solution <span class="op">=</span> np.zeros(matrixSize)</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We iterate in the reverse order on the rows</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> rowIndex <span class="kw">in</span> <span class="bu">range</span>(matrixSize):</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The value pointer is the value of the diagonal.</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    valuePointer <span class="op">=</span> matrix[rowIndex, rowIndex]</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rowIndex <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>      solution[<span class="dv">0</span>] <span class="op">=</span> b[<span class="dv">0</span>] <span class="op">/</span> valuePointer</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    solution[rowIndex] <span class="op">=</span> b[rowIndex] <span class="op">/</span> matrix[rowIndex, rowIndex]</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index <span class="kw">in</span> (<span class="bu">range</span>(<span class="dv">0</span>, rowIndex)):</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>      solution[rowIndex] <span class="op">-=</span> matrix[rowIndex, index] <span class="op">*</span> solution[index] <span class="op">/</span> matrix[rowIndex, rowIndex]</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> solution</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a><span class="co"># After defining the triangular solvers, we can carry on solving the entire system.</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> systemSolver(P, L, U, b):</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>  matrixSize <span class="op">=</span> np.shape(U)</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We have (P^-1)LUx = b, so we should first solve for z, where (P^-1)z = b.</span></span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>  z <span class="op">=</span> np.linalg.solve(P, b)</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Then, we have z = LUx. So let y = Ux. Then Ly = z is a system and we solve for y.</span></span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>  y <span class="op">=</span> lowerSolve(L, z)</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Finally, we have Ux = y.</span></span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> upperSolve(U, y)</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The Linear System solver utilizing PLU factorization has been implemented. To test the accuracy of the algorithm, we can generate random matrices with random solutions.</p>
<div id="8eadcee6" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># From ChatGBT</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_random_nonsingular_matrix(n):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> np.random.rand(n, n)  <span class="co"># Generate a random n x n matrix</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.linalg.det(A) <span class="op">!=</span> <span class="dv">0</span>:  <span class="co"># Check if the determinant is non-zero</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> A</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us time this test. You will see the point soon!</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.perf_counter()</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>matrixCreationTime <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Now let us test it</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>trueTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>falseTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing for 10000 times</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10000</span>):</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Generating random 1 x 10 vector for b and 10 * 10 nonsingular matrices</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>  random <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">100000</span>, size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># I am also timing how long the matrix creation and PLU calculation is</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>  start_1 <span class="op">=</span> time.perf_counter()</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>  randomSquare <span class="op">=</span> generate_random_nonsingular_matrix(<span class="dv">10</span>)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>  end_1 <span class="op">=</span> time.perf_counter()</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>  P, L, U <span class="op">=</span> PLUSystemSolver(randomSquare)</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>  matrixCreationTime <span class="op">+=</span> end_1 <span class="op">-</span> start_1</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Test case</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> systemSolver(P, L, U, random).<span class="bu">all</span>() <span class="op">==</span> np.linalg.solve(randomSquare, random).<span class="bu">all</span>():</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>    trueTimes <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    falseTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(randomSquare, random)</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of Times the Algorithm is Correct: "</span>, trueTimes)</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of Times the Algorithm is Incorrect: "</span>, falseTimes)</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time.perf_counter()</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> end <span class="op">-</span> start</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The total test took </span><span class="sc">{</span>duration<span class="sc">:.6f}</span><span class="ss"> seconds. </span><span class="ch">\n</span><span class="ss"> The matrix creation took a total of </span><span class="sc">{</span>matrixCreationTime<span class="sc">:.6f}</span><span class="ss"> seconds."</span>)</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test time subtracted by matrix creation time is </span><span class="sc">{</span>duration <span class="op">-</span> matrixCreationTime<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of Times the Algorithm is Correct:  10000
Number of Times the Algorithm is Incorrect:  0
The total test took 5.055142 seconds. 
 The matrix creation took a total of 0.119841 seconds.
Test time subtracted by matrix creation time is 4.935301</code></pre>
</div>
</div>
<p>We see from the results of the test. After generating 10000 random 1 x 10 vectors for b and 10 * 10 nonsingular matrices, the algorithm always matches the linalg solution. We can conclude with confidence that our algorithm works well.</p>
<p>Let us try something. Instead of creating a random matrix everytime, let us just use the same matrix. Everything else is the same.</p>
<div id="c2a40136" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>trueTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>falseTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>randomSquare <span class="op">=</span> generate_random_nonsingular_matrix(<span class="dv">10</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>P, L, U <span class="op">=</span> PLUSystemSolver(randomSquare)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> time.perf_counter()</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing for 10000 times</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10000</span>):</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Generating random 1 x 10 vector for b and 10 * 10 nonsingular matrices</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  random <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">100000</span>, size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Keeping the time counters to keep the timing same as last block's test.</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  start_1 <span class="op">=</span> time.perf_counter()</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  end_1 <span class="op">=</span> time.perf_counter()</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  matrixCreationTime <span class="op">+=</span> end_1 <span class="op">-</span> start_1</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Test case</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> systemSolver(P, L, U, random).<span class="bu">all</span>() <span class="op">==</span> np.linalg.solve(randomSquare, random).<span class="bu">all</span>():</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    trueTimes <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    falseTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(randomSquare, random)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of Times the Algorithm is Correct: "</span>, trueTimes)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of Times the Algorithm is Incorrect: "</span>, falseTimes)</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> time.perf_counter()</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> end <span class="op">-</span> start</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The test took </span><span class="sc">{</span>duration<span class="sc">:.6f}</span><span class="ss"> seconds."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of Times the Algorithm is Correct:  10000
Number of Times the Algorithm is Incorrect:  0
The test took 1.396865 seconds.</code></pre>
</div>
</div>
<p>The difference in the times of these tests is noticeable. The second test, which only calculates P, L, U once is noticeably faster than the first test. My hypothesis was that the second test where we did not create random matrices everytime and used the same matrix could be noticeably shorter. This makes sense, as the advantage of PLU is the fact that once we have PLU, we quickly calculate the solutions corresponding to PLU for any b.</p>
<p>Now, we can create our final inverse matrix finder module! The inverseFinder takes in nonsingular square matrices and output the inverse :)</p>
<div id="cb55cd61" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inverseFinder(matrix):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  matrixSize <span class="op">=</span> np.shape(matrix)[<span class="dv">0</span>]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># First, let us generate the standard coordinate basis that will serve as the</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># b values to the system</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  bSet <span class="op">=</span> []</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(matrixSize):</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> np.zeros(matrixSize)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    e[i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    bSet.append(e)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  P, L, U <span class="op">=</span> PLUSystemSolver(matrix)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Now we can obtain the solutino set</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  solutionSet <span class="op">=</span> []</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> b <span class="kw">in</span> bSet:</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    solutionSet.append(systemSolver(P, L, U, b))</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>  transpose <span class="op">=</span> np.array(solutionSet)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>  answer <span class="op">=</span> transpose.T</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> answer</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple test</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inverseFinder(A))</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.linalg.inv(A))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[-3.  -1.5  0.5]
 [ 7.   3.  -1. ]
 [ 5.   2.  -1. ]]
[[-3.  -1.5  0.5]
 [ 7.   3.  -1. ]
 [ 5.   2.  -1. ]]</code></pre>
</div>
</div>
<p>Yay, the inverse finder is finished. Similar to the systemSolver algorithm, let us test it more extensively by generating random nonsingular square matrices.</p>
<div id="3bcb21e7" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>trueTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>falseTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing for 10000 times</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10000</span>):</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Generating random 1 x 10 vector for b and 10 * 10 nonsingular matrices</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  randomSquare <span class="op">=</span> generate_random_nonsingular_matrix(<span class="dv">10</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Test case</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> np.linalg.inv(randomSquare).<span class="bu">all</span>() <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> inverseFinder(randomSquare).<span class="bu">all</span>() <span class="op">==</span> np.linalg.inv(randomSquare).<span class="bu">all</span>():</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>      trueTimes <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>      falseTimes <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(randomSquare)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of Times the Algorithm is Correct: "</span>, trueTimes)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of Times the Algorithm is Incorrect: "</span>, falseTimes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of Times the Algorithm is Correct:  10000
Number of Times the Algorithm is Incorrect:  0</code></pre>
</div>
</div>
<p>This code will take a little while to run. But after it finishes, we see that the inverseFinder algorithm works very well! There is no time when the algorithm is wrong during this test. It is important to note the limitations of the algorithm systemSolver and inverseFInder as they can only take square nonsingular matrices. In other words, matrices with a nonzero determinant. However, this is expected as the inverse can only be found for matrices with zero determinant. Therefore, the only big limitation will be for systemSolver. We cannot use this algorithm to solve singular matrices or matrix systems with infinite solutions. However, it is also important to note the strength of these algorithms. It uses a relatively clear and straigtforward process to find the system solution and the inverses. Once the PLU matrices are found, the solutions for the linear system corresponding to PLU for any b can be found with small computing power.</p>
<div class="comments">
<p>Grade: Still E :-)</p>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions"><ul><li><a href="https://github.com/KBurbank/stat24320/edit/main/submitted/projects_1_revised/caihanyan_173267_11271607_First_Projects_Revised.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/KBurbank/stat24320/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>