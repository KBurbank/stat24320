---
title: Xiao Wei
jupyter: python3
css: comments.css
---

# Markov Chains

For this problem, we are given the transition stochastic matrices of market shares for a market composed of three players. The exercise asks us to find steady state of market shares under a hypothetical scenario where we have to choose between two different transition matrices.

```{python}
import sympy as sym
sb = sym.Symbol
import pandas as pd
```

The transition matrix

```{python}
M = sym.Matrix([[.5, .2, .3],[.2, .6, .1], [.3, .2, .6]])
M
```

The market shares 3 years later if the starting state is the market split evenly between the 3 players. I was a bit surprised that company 2 got the least amount of share instead of company 1 since company 1 has the smallest value in the diagonal meaning they keep less of their own customers in each subsequent state.

```{python}
M**3 * sym.Matrix([0.33333, 0.33333, 0.33333])
```

First campaign transition matrix

```{python}
Mc1 = sym.Matrix([[.5, .32, .3],[.2, .48, .1], [.3, .2, .6]])
Mc1
```

To calculate the steady state of the market shares, we multiply the transition matrix large number of times

```{python}
Mc1**50 * sym.Matrix([0.33333, 0.33333, 0.33333])
```

As a check we can use the transition matrix one more time to see that the market share stays the same

```{python}
Mc1**51 * sym.Matrix([0.33333, 0.33333, 0.33333])
```

I'm not sure why this solution doesn't work, as it would serve as a good proof of the steady state. The steady state is the vector in which the transition matrix applied to the vector results in the same vector.

formula:

Ax = x

A(x - I) = 0

::: comments
I've just spent a while playing around with this! The matrix is ill-conditioned, so the solver is having trouble. It ends up deciding that the matrix is singular and giving you the trivial solution. But it's not singular, it's just very close to it.

In any case, you *do* get the right result just by finding the eigenvectors of Mc1; the eigenvector corresponding to the eigenvalue 1 is the steady state you found. So odd! But it's a good reminder that numerical linear algebra can be a bit of a minefield.
:::


```{python}
(sym.eye(3) - Mc1).gauss_jordan_solve(sym.zeros(3, 1))[0]
```

We can also see that the intial state doesn't matter when calculating the steady state

```{python}
Mc1**50 * sym.Matrix([0, 1, 0])
```

second campaign transition matrix

```{python}
Mc2 = sym.Matrix([[.5, .32, .3+.6*.2],[.2, .48, .1], [.3, .2, .6*.8]])
Mc2
```

```{python}
Mc2**50 * sym.Matrix([0.33333, 0.33333, 0.33333])
```

::: comments
So you've shown here that the long-term behavior is the same for each of the two initial distributions you chose. To convince yourself that this is truly universal, though, you'd want to try a number of different initial distributions, not just two.

(Of course, using the concepts of eigenvalues and eigenvectors, we can see that the steady state you found corresponds to the dominant eigenvector of the matrix. That means that you will tend to arrive there unless your initial distribution is orthogonal to that eigenvector, exactly equal to one of the other eigenvectors. You wouldn't have found one of these other eigenvectors anyways just trying initial distributions by chance...)
:::


### Report

It is better to run campaign 2 as the steady state vector for campaign 2 is 43% vs 38% for campaign 1. It does not matter what the starting state is the end state after many iterations would be the same. As such the second campaign has insurance company A with a higher market share.

Below is the chart for the net gain our company A gains from either company B for marketing campaign 1 or company C for marketing campaign 2 for each subsequent iteration.

Implicit assumption of this model is that the effectiveness of each marketing campaign in driving consumer behavior remains constant across each time period. This is most likely not the case in reality. In either case though it looks like marketing campaign 2 is the better campaign unless company B has a lot more customers than company C in the initial period.

The below code iterates through states and calculates in each state how much company A gains from B or company C depending on whether marketing strategy 1 or 2 was chosen

```{python}
c1_state = sym.Matrix([0.33333, 0.33333, 0.33333])
c2_state = sym.Matrix([0.33333, 0.33333, 0.33333])
gains = pd.DataFrame([], columns=['Percentage from B', 'Percentage from C'])
gain_from_b = 0
gain_from_c = 0
for step in range(21):
    gains.loc[int(step)] = (gain_from_b, gain_from_c)
    next_state_c1 = Mc1 * c1_state
    next_state_c2 = Mc2 * c2_state
    gain_from_b = next_state_c1[1] * Mc1[0, 1] - c1_state[0] * Mc1[1, 0]
    gain_from_c = next_state_c2[2] * Mc2[0, 2] - c2_state[0] * Mc1[2, 0]
    c1_state = next_state_c1
    c2_state = next_state_c2
```

```{python}
gains = gains.astype(float)
```

```{python}
gains.plot(kind='line', xlabel='state iterations', ylabel="proportion from", title="Market Share from B or C")
```

::: comments
This meets expectations now! Grade: M
:::


# Diffusion



For the diffusion project, we are given the problem of finding the concentration at each of the 7 segments of a tube at each time step. However, we are not given the initial amount of gas released into the middle of the tube and are only given two measurements at time step t240 and t270 as seen below. We must use linear algebra to approximate the diffusion equation using a transition matrix and guess the values of the intial concentration as well as the diffusion constant. 

```{python}
import sympy as sym
import numpy as np
import pandas as pd
sb = sym.Symbol
```

![image.png](attachment:bd15908d-1d58-4c2a-9049-68fd84558378.png)

In the below cell I create the transition matrix for each segment of the tube. The transition equation was part of equation 3.10

There are a total of 7 segments measured which results in a 7x7 transition matrix, each segment is a function of itself and its adjoining segments and the constants D, h.

```{python}
N=7
M = sym.zeros(N)
for i in range(N):
  if (i>0):
      M[i-1,i]=1
  M[i,i]=-2
  if (i<N-1):
      M[i+1,i]=1
  # M[0, i] = 0
  # M[6, i] = 0
#   M[i, 0] = 0
#   M[i, 6] = 0
# M[5, 6] = 0
M
```

Here are the starting states for T270 and T240 according to the textbook (see snippet above)

```{python}
t270 = sym.Matrix([0.0, 0.051, 1.21, 3.48, 1.21, 0.051, 0.0])
t240 = sym.Matrix([0.0, 0.032, 1.23, 3.69, 1.23, 0.032, 0.0])
```

Going forward from 240 to 270, I tried various figures for D here and settled on the one below. Note the 36 is supposed to represent 1/h^2

transition formula

t_i+1 = t_i + M * t_i * D/h^2

```{python}
Dh2 = 0.00004 * 36

current = t240
for step in range(240, 271):
    next_step = current + M*current * Dh2
    if step % 10 == 0:
        print(step, current)
        print('\n')
    current = next_step
```

Now that I have settled on a value for D. I will move backwards from 270 to 0. Output is every 30 steps and 0. As gone over in class, the transition matrix and multiplier needs to be taken with an inverse since we are now moving backwards instead of forwards as in the equation given by the text book.

transition formula:

t_i+1 = t_i + M * t_i * D/h^2

t_i+1 = t_i

t_i = (I + M*D/h^2)^-1 *t_i+1

```{python}
Dh2 = 0.00004 * 36

current = t270
for step in range(270, -1, -1):
    prev_step = (sym.eye(current.shape[0]) + M* Dh2).inv()*current 
    if step % 40 == 0:
        print(step, current)
        print('\n')
    current = sym.Matrix(np.maximum(prev_step, 0))
print(step, current)
init_state = current
```

I assume the tube is empty except for the initial release in the middle at state 0. The initial amount "f", is the max of step 0 from above. I output the amounts for time 210 and 300 as per the assignment instructions.

```{python}
import warnings
warnings.filterwarnings("ignore")
current = sym.zeros(7, 1)
current[3] = np.max(init_state)
plot_df = pd.DataFrame([], columns=['0', '1/6', '1/3', '1/2'], dtype=np.float64)
for step in range(0, 301):
    plot_df.loc[step] = current[:4]
    next_step = current + M*current * Dh2
    if step==0 or step ==210 or step == 300:
        print(step, current)
        print('\n')
    current = next_step
plot_df.loc[step] = current[:4]
```

Since the readings are symmetrical across the middle I only plot half the tube including the middle. Each line below is a reading at each segment from 0 to 1/2.

```{python}
plot_df = plot_df.astype(np.float_)
plot_df.plot(kind='line', xlabel="step", ylabel='concentration', title="concentration at each time step for segment measurements")
```

It is expected that the center curve looks like an logarithmic decay, the 1/3 curve looks like a logarithmic increase which I suppose will decrease at the point. Using Linear Algebra does seem like a much easier approach than the actual Physics of computing the diffusion constant as well as the intial concentration.

::: comments
This is a great solution! You've done a good job of explaining your reasoning and the steps you took to arrive at your solution. The plots are clear and easy to understand. 

Grade: E
:::




# Sports Ranking



This problem explores loading tournament data into graph format and producing rankings using matrix arithmetic/algebra. It explores using simple rank, power rank, and inverse pagerank as different ranking algorithms and compares/contrasts each method.

```{python}
import sympy as sym
import numpy as np
import pandas as pd
import networkx as nx
sb = sym.Symbol
sm = sym.Matrix
```

Loading the data into networkx

```{python}
G = nx.DiGraph()
G.add_nodes_from([1, 2, 3, 4, 5, 6, 7])
G.add_edges_from([(1, 2), (7, 3), (2, 4), (4, 5), (3, 2), (5, 1), (6, 1), (3, 1), (7, 2), (2, 6), (3, 4), (7, 4)
                  , (5, 7), (6, 4), (3, 5), (5, 6), (7, 1), (5, 2), (7, 6), (1, 4), (6, 3)])
```

Draw the graph

```{python}
nx.draw(G, with_labels=True)
```

#### adjacency matrix

```{python}
adj_mat = nx.to_numpy_array(G)
adj_mat
```

#### win-loss record

```{python}
wins = adj_mat.sum(axis=1)
wins
```

```{python}
losses = adj_mat.sum(axis=0)
losses
```

### Simple Rank
Here is the simple ranking for each team/node by wins

```{python}
team = pd.DataFrame({'wins': wins, 'losses': losses}, index=range(1, 8))
team.sort_values(['wins', 'losses'], ascending=[False, True])
```

#### Vertex Power

Power ranking: A + A^2

```{python}
power_rank = (adj_mat + adj_mat**2).sum(axis=1)
pd.Series(power_rank, index=range(1, 8)).sort_values(ascending=False)
```

#### Reverse PageRank

Here I transform the adjacency matrix into a stochastic transition matrix by dividing each column by the sum of degrees

```{python}
col_sums = adj_mat.sum(axis=0)
P = np.zeros(adj_mat.shape)
for i in range(adj_mat.shape[0]):
    P[i, :] = adj_mat[i, :] / col_sums
pd.DataFrame(P)
```

As per instructions, 85% chance of using the transition matrix and 15% chance of teleportation to a random node

```{python}
alpha = 0.85
v = sym.ones(adj_mat.shape[0])[:, 0] / adj_mat.shape[0]
v
```

Formula:

(I - aP)

```{python}
pg_mat = (sym.eye(P.shape[0]) - alpha * P)
pg_mat
```

solving for:

(I - aP)x = (1 - a)v

The output is the reverse page rank ranking

```{python}
pd.Series(list(pg_mat.gauss_jordan_solve(v* (1-alpha))[0]), index=range(1, 8)).sort_values(ascending=False)
```

#### Weighted graph power ranking

I add weights using networkx and output the resulting weighted adjacency matrix

```{python}
Gw = nx.DiGraph()
Gw.add_nodes_from([1, 2, 3, 4, 5, 6, 7])
Gw.add_weighted_edges_from([(1, 2, 4), (7, 3, 8), (2, 4, 7), (4, 5, 3), (3, 2, 7), (5, 1, 7), (6, 1, 23)
                            , (3, 1, 15), (7, 2, 6), (2, 6, 18), (3, 4, 13), (7, 4, 14)
                  , (5, 7, 7), (6, 4, 13), (3, 5, 7), (5, 6, 18), (7, 1, 45), (5, 2, 10), (7, 6, 19), (1, 4, 13), (6, 3, 13)])
adj_matw = nx.to_numpy_array(Gw)
adj_matw
```

The power rank using weighted edges

```{python}
pd.Series((adj_matw + adj_matw**2).sum(axis=1), index=range(1, 8)).sort_values(ascending=False)
```


